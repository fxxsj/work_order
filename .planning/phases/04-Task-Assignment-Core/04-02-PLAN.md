---
phase: 04-Task-Assignment-Core
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/workorder/services/task_assignment.py
  - backend/workorder/views/work_order_tasks/task_main.py
  - frontend/src/api/modules/workorder-task.js
autonomous: true

must_haves:
  truths:
    - "Operator can claim unassigned task within their department"
    - "Claim action uses select_for_update to prevent concurrent claims"
    - "Successfully claimed task shows operator as assigned_operator"
    - "Operator cannot claim task already assigned to another operator"
    - "Claim endpoint validates operator belongs to task's department"
    - "Claim fails with clear message if operator already has maximum active tasks"
  artifacts:
    - path: "backend/workorder/services/task_assignment.py"
      provides: "TaskAssignmentService.claim_task method"
      contains: "def claim_task"
    - path: "backend/workorder/views/work_order_tasks/task_main.py"
      provides: "claim_action endpoint"
      exports: ["claim"]
    - path: "frontend/src/api/modules/workorder-task.js"
      provides: "claimTask method"
      contains: "claimTask"
  key_links:
    - from: "backend/workorder/views/work_order_tasks/task_main.py"
      to: "backend/workorder/services/task_assignment.py"
      via: "TaskAssignmentService.claim_task"
      pattern: "TaskAssignmentService\\.claim_task"
    - from: "frontend/src/api/modules/workorder-task.js"
      to: "backend/workorder/views/work_order_tasks/task_main.py"
      via: "POST /workorder-tasks/{id}/claim/"
      pattern: "claim/\\s*\\(\\s*id"
---

<objective>
Build operator self-claiming API with optimistic locking

This plan enables operators to self-claim unassigned tasks within their department. The API uses database-level locking (select_for_update) to prevent two operators from simultaneously claiming the same task, ensuring data consistency in concurrent scenarios.

Purpose: Allow operators to proactively claim available tasks without supervisor intervention
Output: Working claim endpoint with concurrency protection
</objective>

<execution_context>
@/home/chenjiaxing/.claude/get-shit-done/workflows/execute-plan.md
@/home/chenjiaxing/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/workorder/models/core.py
@backend/workorder/services/task_assignment.py
@backend/workorder/views/work_order_tasks/task_main.py
@.planning/phases/04-Task-Assignment-Core/04-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Add claim_task method to TaskAssignmentService with concurrency control</name>
  <files>backend/workorder/services/task_assignment.py</files>
  <action>
Add the following method to TaskAssignmentService in `backend/workorder/services/task_assignment.py`:

```python
    @staticmethod
    @transaction.atomic
    def claim_task(task_id: int, operator, notes: Optional[str] = None) -> Dict[str, Any]:
        """操作员认领任务

        允许操作员认领未分配的任务。使用 select_for_update 实现乐观锁，
        防止两个操作员同时认领同一任务。

        业务规则：
        - 操作员必须属于任务分配的部门
        - 任务必须已分配到部门（assigned_department 不为空）
        - 任务当前未分配给其他操作员（assigned_operator 为空）
        - 任务状态为 pending 或 in_progress
        - 草稿状态的任务不能认领

        Args:
            task_id: 任务ID
            operator: 认领任务的操作员
            notes: 认领备注（可选）

        Returns:
            Dict: 包含更新后任务信息的字典

        Raises:
            BusinessLogicError: 业务规则不满足
            WorkOrderTask.DoesNotExist: 任务不存在
        """
        from django.contrib.auth.models import User

        # 使用 select_for_update 行锁，防止并发认领
        try:
            task = WorkOrderTask.objects.select_for_update().get(id=task_id)
        except WorkOrderTask.DoesNotExist:
            raise BusinessLogicError(f"任务ID {task_id} 不存在")

        # 验证操作员属于任务部门
        if not task.assigned_department:
            raise BusinessLogicError(
                "该任务尚未分配到部门，无法认领"
            )

        if not PermissionCache.is_user_in_department(operator, task.assigned_department.id):
            raise BusinessLogicError(
                f"您不属于部门 {task.assigned_department.name}，无法认领该任务"
            )

        # 验证操作员任务容量（复用分配服务的验证方法）
        TaskAssignmentService.validate_operator_task_capacity(operator)

        # 验证任务可认领性
        if task.status == 'draft':
            raise BusinessLogicError(
                "草稿状态的任务不能认领，请先等待施工单审核通过"
            )

        if task.status == 'completed':
            raise BusinessLogicError(
                "已完成的任务不能认领"
            )

        if task.status == 'cancelled':
            raise BusinessLogicError(
                "已取消的任务不能认领"
            )

        # 检查任务是否已被其他操作员认领
        if task.assigned_operator:
            # 如果是被自己认领的，允许更新
            if task.assigned_operator.id == operator.id:
                return {
                    'task_id': task.id,
                    'assigned_operator': {
                        'id': operator.id,
                        'username': operator.username,
                        'first_name': operator.first_name,
                        'last_name': operator.last_name
                    },
                    'already_claimed': True,
                    'message': '您已经认领了该任务'
                }

            # 被其他人认领
            raise BusinessLogicError(
                f"该任务已被 {task.assigned_operator.username} 认领，无法重复认领"
            )

        # 执行认领
        task.assigned_operator = operator
        task.save(update_fields=['assigned_operator', 'updated_at'])

        # 创建任务认领通知
        work_order = task.work_order_process.work_order if task.work_order_process else None
        Notification.create_notification(
            recipient=operator,
            notification_type='task_assigned',
            title=f'任务认领成功：{task.work_content}',
            content=f'您已成功认领任务 "{task.work_content}"。'
                    f'施工单：{work_order.order_number if work_order else "N/A"}'
                    f'{f" 备注：{notes}" if notes else ""}',
            priority='normal',
            work_order=work_order,
            work_order_process=task.work_order_process,
            task=task
        )

        logger.info(
            f"任务认领：用户 {operator.username} 认领了任务 {task_id}"
        )

        return {
            'task_id': task.id,
            'assigned_operator': {
                'id': operator.id,
                'username': operator.username,
                'first_name': operator.first_name,
                'last_name': operator.last_name
            },
            'already_claimed': False,
            'message': '任务认领成功'
        }

    @staticmethod
    def get_claimable_tasks_for_user(user) -> list:
        """获取用户可认领的任务列表

        返回用户所属部门中、未分配操作员、状态为 pending 的任务

        Args:
            user: 当前用户

        Returns:
            list: 可认领的任务ID列表
        """
        if not user.is_authenticated:
            return []

        # 获取用户所属部门
        user_departments = PermissionCache.get_user_departments(user)

        if not user_departments:
            return []

        # 查询可认领的任务
        claimable_tasks = WorkOrderTask.objects.filter(
            assigned_department_id__in=user_departments,
            assigned_operator__isnull=True,
            status='pending'
        ).values_list('id', flat=True)

        return list(claimable_tasks)
```

Also update the logger import at the top if not already present.
  </action>
  <verify>TaskAssignmentService contains claim_task method with select_for_update and get_claimable_tasks_for_user method</verify>
  <done>Claim service method added with concurrency control</done>
</task>

<task type="auto">
  <name>Add claim action endpoint to BaseWorkOrderTaskViewSet</name>
  <files>backend/workorder/views/work_order_tasks/task_main.py</files>
  <action>
Add the claim action to BaseWorkOrderTaskViewSet in `backend/workorder/views/work_order_tasks/task_main.py`:

Add after the assign action:

```python
    @action(detail=True, methods=['post'], url_path='claim')
    def claim(self, request, pk=None):
        """操作员认领任务

        POST /workorder-tasks/{id}/claim/
        Body: {
            "notes": "我会尽快完成"  # 可选
        }

        权限：
        - 任务所属部门的操作员

        并发控制：
        使用 select_for_update 防止两个操作员同时认领同一任务
        """
        task = self.get_object()

        # 获取可选的备注
        notes = request.data.get('notes', '') if request.data else ''

        try:
            result = TaskAssignmentService.claim_task(
                task_id=task.id,
                operator=request.user,
                notes=notes
            )

            # 重新获取更新后的任务数据
            task.refresh_from_db()
            response_serializer = self.get_serializer(task)

            return Response({
                'detail': result.get('message', '任务认领成功'),
                'data': result,
                'task': response_serializer.data
            }, status=status.HTTP_200_OK)

        except BusinessLogicError as e:
            return Response({
                'detail': str(e),
                'code': e.default_code
            }, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger = logging.getLogger(__name__)
            logger.error(f"任务认领失败: {str(e)}")
            return Response({
                'detail': '任务认领失败，请稍后重试',
                'error': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @action(detail=False, methods=['get'], url_path='claimable')
    def claimable(self, request):
        """获取当前用户可认领的任务列表

        GET /workorder-tasks/claimable/

        返回用户所属部门中未分配操作员的任务
        """
        try:
            claimable_ids = TaskAssignmentService.get_claimable_tasks_for_user(request.user)

            # 获取完整的任务数据
            queryset = self.get_queryset().filter(id__in=claimable_ids)
            page = self.paginate_queryset(queryset)

            if page is not None:
                serializer = self.get_serializer(page, many=True)
                return self.get_paginated_response({
                    'claimable_count': len(claimable_ids),
                    'results': serializer.data
                })

            serializer = self.get_serializer(queryset, many=True)
            return Response({
                'claimable_count': len(claimable_ids),
                'results': serializer.data
            })

        except Exception as e:
            logger = logging.getLogger(__name__)
            logger.error(f"获取可认领任务列表失败: {str(e)}")
            return Response({
                'detail': '获取可认领任务列表失败',
                'error': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
```
  </action>
  <verify>BaseWorkOrderTaskViewSet contains claim and claimable actions</verify>
  <done>Claim endpoints added with proper error handling</done>
</task>

<task type="auto">
  <name>Add claimTask and getClaimableTasks methods to frontend API</name>
  <files>frontend/src/api/modules/workorder-task.js</files>
  <action>
Update `frontend/src/api/modules/workorder-task.js` to add claim methods:

Add after the assignToOperator method:

```javascript
  // 操作员认领任务
  claimTask(id, data) {
    return this.customAction(`${this.baseUrl}${id}/claim/`, 'post', {
      notes: data.notes || ''
    })
  }

  // 获取当前用户可认领的任务列表
  getClaimableTasks(params) {
    return this.request({
      url: `${this.baseUrl}claimable/`,
      method: 'get',
      params
    })
  }
```
  </action>
  <verify>workorder-task.js contains claimTask and getClaimableTasks methods</verify>
  <done>Frontend API methods added for task claiming</done>
</task>

</tasks>

<verification>
1. TaskAssignmentService.claim_task uses select_for_update for concurrency control
2. Claim endpoint validates operator belongs to task department
3. Claim fails when task already has assigned_operator
4. Claimable tasks endpoint returns correct filtered list
5. Transaction ensures atomic claim operation
6. Notification created on successful claim
7. Frontend API has claimTask method
</verification>

<success_criteria>
1. POST to /workorder-tasks/{id}/claim/ successfully assigns operator to task
2. Concurrent claims are serialized - one succeeds, other fails with clear message
3. Operators outside department receive 400 error when attempting claim
4. Tasks with existing assigned_operator return 400 error
5. GET to /workorder-tasks/claimable/ returns only unassigned tasks in user's department
6. Successful claim creates notification for operator
7. Claim fails with clear error when operator has 10+ active tasks
</success_criteria>

<output>
After completion, create `.planning/phases/04-Task-Assignment-Core/04-02-SUMMARY.md`
</output>
