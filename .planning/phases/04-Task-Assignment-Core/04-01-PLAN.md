---
phase: 04-Task-Assignment-Core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/workorder/services/task_assignment.py
  - backend/workorder/serializers/core.py
  - backend/workorder/views/work_order_tasks/task_main.py
  - backend/workorder/permissions.py
  - frontend/src/api/modules/workorder-task.js
autonomous: true

must_haves:
  truths:
    - "Department supervisor can assign task to operator within their department"
    - "Assignment API validates supervisor has permission for the task's department"
    - "Assigned operator receives notification of new task assignment"
    - "Task cannot be assigned to operator outside the task's department"
    - "API returns clear error message when supervisor lacks permission"
    - "Assignment fails with clear message if operator already has maximum active tasks"
  artifacts:
    - path: "backend/workorder/services/task_assignment.py"
      provides: "TaskAssignmentService with assign_to_operator method"
      min_lines: 80
    - path: "backend/workorder/serializers/core.py"
      provides: "TaskAssignmentSerializer for assignment requests"
      contains: "class TaskAssignmentSerializer"
    - path: "backend/workorder/views/work_order_tasks/task_main.py"
      provides: "assign_action endpoint"
      exports: ["assign"]
    - path: "frontend/src/api/modules/workorder-task.js"
      provides: "assignToOperator method"
      contains: "assignToOperator"
  key_links:
    - from: "backend/workorder/views/work_order_tasks/task_main.py"
      to: "backend/workorder/services/task_assignment.py"
      via: "TaskAssignmentService.assign_to_operator"
      pattern: "TaskAssignmentService\\.assign_to_operator"
    - from: "frontend/src/api/modules/workorder-task.js"
      to: "backend/workorder/views/work_order_tasks/task_main.py"
      via: "POST /workorder-tasks/{id}/assign/"
      pattern: "assign/\\s*\\(\\s*id"
---

<objective>
Implement supervisor assignment API with permission validation

This plan enables department supervisors to manually assign tasks to operators within their department. The supervisor can only assign tasks that belong to departments they supervise, and can only assign to operators who are members of that department.

Purpose: Establish the manual task assignment workflow as a complement to automatic dispatch
Output: Working API endpoint for task assignment with permission checks and notifications
</objective>

<execution_context>
@/home/chenjiaxing/.claude/get-shit-done/workflows/execute-plan.md
@/home/chenjiaxing/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/workorder/models/core.py
@backend/workorder/permissions.py
@backend/workorder/services/dispatch_service.py
@backend/workorder/serializers/core.py
@frontend/src/api/modules/workorder-task.js
@frontend/src/api/base/BaseAPI.js
</context>

<tasks>

<task type="auto">
  <name>Create TaskAssignmentService for supervisor assignment logic</name>
  <files>backend/workorder/services/task_assignment.py</files>
  <action>
Create a new service file `backend/workorder/services/task_assignment.py` with:

```python
"""
任务分配服务

提供任务分配的核心业务逻辑：
- TaskAssignmentService: 主管分配任务给操作员
"""
from typing import Optional, Dict, Any
from django.db import transaction
from django.db.models import Q
from django.utils import timezone
import logging

from ..models.core import WorkOrderTask
from ..models.base import Department
from ..models.system import Notification
from ..exceptions import BusinessLogicError, PermissionDeniedError
from ..permission_utils import PermissionCache

logger = logging.getLogger(__name__)


class TaskAssignmentService:
    """任务分配服务

    处理主管手动分配任务给操作员的业务逻辑
    """

    # 默认每个操作员最多同时处理的任务数
    DEFAULT_MAX_TASKS_PER_OPERATOR = 10

    @staticmethod
    def validate_operator_task_capacity(operator, max_tasks: int = None) -> bool:
        """验证操作员任务容量

        检查操作员当前活跃任务数是否已达上限。

        Args:
            operator: 操作员用户
            max_tasks: 最大任务数限制，默认使用 DEFAULT_MAX_TASKS_PER_OPERATOR

        Returns:
            bool: 未达上限返回True

        Raises:
            BusinessLogicError: 已达上限时抛出
        """
        if max_tasks is None:
            max_tasks = TaskAssignmentService.DEFAULT_MAX_TASKS_PER_OPERATOR

        # 统计操作员当前活跃任务数（状态为 in_progress 的任务）
        active_task_count = WorkOrderTask.objects.filter(
            assigned_operator=operator,
            status='in_progress'
        ).count()

        if active_task_count >= max_tasks:
            raise BusinessLogicError(
                f"该操作员已有 {active_task_count} 个进行中任务，已达上限，"
                f"请先完成部分任务后再分配。"
            )

        return True

    @staticmethod
    def validate_supervisor_permission(user, task: WorkOrderTask) -> bool:
        """验证用户是否有权限分配该任务

        权限规则：
        1. 超级管理员可以分配所有任务
        2. 施工单创建人可以分配其施工单的任务
        3. 任务所属部门的主管可以分配该任务

        Args:
            user: 当前用户
            task: 要分配的任务

        Returns:
            bool: 有权限返回True

        Raises:
            PermissionDeniedError: 无权限时抛出
        """
        # 超级管理员
        if user.is_superuser:
            return True

        # 施工单创建人
        if task.work_order_process and task.work_order_process.work_order:
            if task.work_order_process.work_order.created_by == user:
                return True

        # 检查是否是任务所属部门的主管
        if task.assigned_department:
            if PermissionCache.is_user_in_department(user, task.assigned_department.id):
                # 检查是否有 change_workorder 权限（主管权限）
                if user.has_perm('workorder.change_workorder'):
                    return True

        raise PermissionDeniedError(
            "您没有权限分配此任务。只有任务所属部门的主管或施工单创建人可以分配。"
        )

    @staticmethod
    def validate_operator_in_department(operator, department: Department) -> bool:
        """验证操作员是否属于指定部门

        Args:
            operator: 操作员用户
            department: 部门

        Returns:
            bool: 属于部门返回True

        Raises:
            BusinessLogicError: 不属于部门时抛出
        """
        if not operator or not operator.is_active:
            raise BusinessLogicError("指定的操作员不存在或未激活")

        if not PermissionCache.is_user_in_department(operator, department.id):
            raise BusinessLogicError(
                f"操作员 {operator.username} 不属于部门 {department.name}，"
                f"无法分配该部门的任务"
            )

        return True

    @staticmethod
    def validate_task_assignment_eligibility(task: WorkOrderTask) -> bool:
        """验证任务是否可以分配

        规则：
        - 草稿状态的任务不能分配
        - 已完成的任务不能重新分配
        - 已取消的任务不能分配

        Args:
            task: 要分配的任务

        Returns:
            bool: 可以分配返回True

        Raises:
            BusinessLogicError: 不可分配时抛出
        """
        if task.status == 'draft':
            raise BusinessLogicError(
                "草稿状态的任务不能分配，请先等待施工单审核通过"
            )

        if task.status == 'completed':
            raise BusinessLogicError(
                "已完成的任务不能重新分配"
            )

        if task.status == 'cancelled':
            raise BusinessLogicError(
                "已取消的任务不能分配"
            )

        # 任务必须有分配的部门
        if not task.assigned_department:
            raise BusinessLogicError(
                "任务尚未分配到部门，无法分配操作员"
            )

        return True

    @staticmethod
    @transaction.atomic
    def assign_to_operator(task_id: int, operator_id: int, assigned_by,
                          notes: Optional[str] = None) -> Dict[str, Any]:
        """将任务分配给指定操作员

        执行步骤：
        1. 加载任务和操作员
        2. 验证分配权限
        3. 验证操作员属于任务部门
        4. 验证任务可分配性
        5. 更新任务分配信息
        6. 创建通知
        7. 记录操作日志

        Args:
            task_id: 任务ID
            operator_id: 操作员用户ID
            assigned_by: 执行分配的用户（主管）
            notes: 分配备注（可选）

        Returns:
            Dict: 包含更新后任务信息的字典

        Raises:
            PermissionDeniedError: 权限不足
            BusinessLogicError: 业务规则不满足
            WorkOrderTask.DoesNotExist: 任务不存在
        """
        from django.contrib.auth.models import User

        # 加载任务（使用 select_for_update 进行行锁）
        try:
            task = WorkOrderTask.objects.select_for_update().get(id=task_id)
        except WorkOrderTask.DoesNotExist:
            raise BusinessLogicError(f"任务ID {task_id} 不存在")

        # 加载操作员
        try:
            operator = User.objects.get(id=operator_id)
        except User.DoesNotExist:
            raise BusinessLogicError(f"操作员ID {operator_id} 不存在")

        # 验证分配权限
        TaskAssignmentService.validate_supervisor_permission(assigned_by, task)

        # 验证操作员任务容量
        TaskAssignmentService.validate_operator_task_capacity(operator)

        # 验证操作员属于任务部门
        TaskAssignmentService.validate_operator_in_department(operator, task.assigned_department)

        # 验证任务可分配性
        TaskAssignmentService.validate_task_assignment_eligibility(task)

        # 记录原操作员（用于日志）
        previous_operator = task.assigned_operator

        # 执行分配
        task.assigned_operator = operator
        task.save(update_fields=['assigned_operator', 'updated_at'])

        # 创建任务分配通知
        work_order = task.work_order_process.work_order if task.work_order_process else None
        Notification.create_notification(
            recipient=operator,
            notification_type='task_assigned',
            title=f'新任务分配：{task.work_content}',
            content=f'{assigned_by.username} 将任务 "{task.work_content}" 分配给您。'
                    f'施工单：{work_order.order_number if work_order else "N/A"}'
                    f'{f"（原操作员：{previous_operator.username}）" if previous_operator else ""}'
                    f'{f" 备注：{notes}" if notes else ""}',
            priority='normal',
            work_order=work_order,
            work_order_process=task.work_order_process,
            task=task
        )

        logger.info(
            f"任务分配：用户 {assigned_by.username} 将任务 {task_id} "
            f"分配给 {operator.username}"
        )

        return {
            'task_id': task.id,
            'assigned_operator': {
                'id': operator.id,
                'username': operator.username,
                'first_name': operator.first_name,
                'last_name': operator.last_name
            },
            'assigned_by': {
                'id': assigned_by.id,
                'username': assigned_by.username
            },
            'assigned_at': timezone.now().isoformat()
        }

    @staticmethod
    def get_department_operators(department_id: int) -> list:
        """获取部门的所有操作员

        Args:
            department_id: 部门ID

        Returns:
            list: 操作员列表，每个包含 id, username, first_name, last_name
        """
        from django.contrib.auth.models import User

        department = Department.objects.get(id=department_id)
        users = User.objects.filter(
            profile__departments=department,
            is_active=True
        ).exclude(
            is_superuser=True
        ).values('id', 'username', 'first_name', 'last_name')

        return list(users)

    @staticmethod
    def get_assignable_tasks_for_department(department_id: int, user) -> list:
        """获取用户可分配的部门任务列表

        只返回未分配操作员或可重新分配的任务

        Args:
            department_id: 部门ID
            user: 当前用户（用于权限检查）

        Returns:
            list: 可分配的任务ID列表
        """
        # 超级管理员可以分配所有任务
        if user.is_superuser:
            return list(WorkOrderTask.objects.filter(
                assigned_department_id=department_id,
                status__in=['pending', 'in_progress']
            ).values_list('id', flat=True))

        # 部门主管可以分配本部门任务
        if PermissionCache.is_user_in_department(user, department_id):
            if user.has_perm('workorder.change_workorder'):
                return list(WorkOrderTask.objects.filter(
                    assigned_department_id=department_id,
                    status__in=['pending', 'in_progress']
                ).values_list('id', flat=True))

        # 施工单创建人可以分配自己施工单的任务
        return list(WorkOrderTask.objects.filter(
            assigned_department_id=department_id,
            status__in=['pending', 'in_progress'],
            work_order_process__work_order__created_by=user
        ).values_list('id', flat=True))
```
  </action>
  <verify>File exists with class TaskAssignmentService containing assign_to_operator, validate_supervisor_permission, validate_operator_in_department, validate_task_assignment_eligibility, validate_operator_task_capacity methods</verify>
  <done>TaskAssignmentService file created with all validation and assignment logic including task capacity check</done>
</task>

<task type="auto">
  <name>Add TaskAssignmentSerializer and update views with assign endpoint</name>
  <files>backend/workorder/serializers/core.py</files>
  <action>
1. Add TaskAssignmentSerializer to `backend/workorder/serializers/core.py` (after DraftTaskBulkSerializer):

```python
class TaskAssignmentSerializer(serializers.Serializer):
    """任务分配序列化器"""
    operator_id = serializers.IntegerField(help_text='操作员用户ID')
    notes = serializers.CharField(required=False, allow_blank=True, help_text='分配备注')

    def validate_operator_id(self, value):
        """验证操作员ID"""
        from django.contrib.auth.models import User
        if not User.objects.filter(id=value, is_active=True).exists():
            raise serializers.ValidationError("指定的操作员不存在或未激活")
        return value
```

2. Update `backend/workorder/views/work_order_tasks/task_main.py` to add the assign action:

Add at the end of BaseWorkOrderTaskViewSet class:

```python
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework import status
from workorder.services.task_assignment import TaskAssignmentService
from workorder.exceptions import BusinessLogicError, PermissionDeniedError

# In BaseWorkOrderTaskViewSet class, add:

    @action(detail=True, methods=['post'], url_path='assign')
    def assign(self, request, pk=None):
        """分配任务给指定操作员

        POST /workorder-tasks/{id}/assign/
        Body: {
            "operator_id": 123,
            "notes": "优先处理此任务"  # 可选
        }

        权限：
        - 任务所属部门的主管
        - 施工单创建人
        - 超级管理员
        """
        from workorder.serializers.core import TaskAssignmentSerializer

        task = self.get_object()
        serializer = TaskAssignmentSerializer(data=request.data)

        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        try:
            result = TaskAssignmentService.assign_to_operator(
                task_id=task.id,
                operator_id=serializer.validated_data['operator_id'],
                assigned_by=request.user,
                notes=serializer.validated_data.get('notes', '')
            )

            # 重新获取更新后的任务数据
            task.refresh_from_db()
            response_serializer = self.get_serializer(task)

            return Response({
                'detail': '任务分配成功',
                'data': result,
                'task': response_serializer.data
            }, status=status.HTTP_200_OK)

        except (PermissionDeniedError, BusinessLogicError) as e:
            return Response({
                'detail': str(e),
                'code': e.default_code
            }, status=status.HTTP_403_FORBIDDEN if isinstance(e, PermissionDeniedError) else status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            logger = logging.getLogger(__name__)
            logger.error(f"任务分配失败: {str(e)}")
            return Response({
                'detail': '任务分配失败，请稍后重试',
                'error': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    @action(detail=False, methods=['get'], url_path='department-operators')
    def department_operators(self, request):
        """获取部门操作员列表

        GET /workorder-tasks/department-operators/?department_id=123

        用于任务分配时选择操作员
        """
        from workorder.models.base import Department

        department_id = request.query_params.get('department_id')
        if not department_id:
            return Response({
                'detail': '请提供 department_id 参数'
            }, status=status.HTTP_400_BAD_REQUEST)

        try:
            operators = TaskAssignmentService.get_department_operators(department_id)
            return Response({
                'department_id': int(department_id),
                'operators': operators
            })
        except Department.DoesNotExist:
            return Response({
                'detail': f'部门ID {department_id} 不存在'
            }, status=status.HTTP_404_NOT_FOUND)
```
  </action>
  <verify>TaskAssignmentSerializer exists in serializers/core.py and assign action exists in task_main.py</verify>
  <done>Serializer and assign endpoint added with proper error handling</done>
</task>

<task type="auto">
  <name>Add assignToOperator method to frontend API module</name>
  <files>frontend/src/api/modules/workorder-task.js</files>
  <action>
Update `frontend/src/api/modules/workorder-task.js` to add the assign operator method:

Add after the existing `assign` method (around line 26):

```javascript
  // 分配任务给指定操作员（主管分配）
  assignToOperator(id, data) {
    return this.customAction(`${this.baseUrl}${id}/assign/`, 'post', {
      operator_id: data.operator_id,
      notes: data.notes || ''
    })
  }

  // 获取部门操作员列表
  getDepartmentOperators(departmentId) {
    return this.request({
      url: `${this.baseUrl}department-operators/`,
      method: 'get',
      params: { department_id: departmentId }
    })
  }
```

The existing `assign` method is for reassignment adjustments. The new `assignToOperator` is specifically for supervisor-to-operator assignment.
  </action>
  <verify>workorder-task.js contains assignToOperator and getDepartmentOperators methods</verify>
  <done>Frontend API methods added for task assignment</done>
</task>

</tasks>

<verification>
1. Backend service file exists with complete assignment logic
2. Serializer validates operator_id field
3. ViewSet assign action handles POST requests with permission validation
4. Frontend API module has assignToOperator method
5. Error responses include user-friendly messages
6. Notification is created on successful assignment
7. Transaction ensures atomic assignment operation
</verification>

<success_criteria>
1. POST to /workorder-tasks/{id}/assign/ with operator_id successfully assigns task
2. Non-department supervisors receive 403 error when attempting assignment
3. Operators outside department receive 400 error with clear message
4. Draft and completed tasks cannot be assigned (400 error)
5. Assigned operator receives notification of new task
6. Department operators endpoint returns valid operator list
7. Assignment fails with clear error when operator has 10+ active tasks
</success_criteria>

<output>
After completion, create `.planning/phases/04-Task-Assignment-Core/04-01-SUMMARY.md`
</output>
