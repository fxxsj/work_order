---
phase: 04-Task-Assignment-Core
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - backend/workorder/services/task_assignment.py
  - backend/workorder/exceptions.py
  - backend/workorder/views/work_order_tasks/task_main.py
  - frontend/src/utils/errorHandler.js
autonomous: true

must_haves:
  truths:
    - "Two operators claiming the same task simultaneously see clear conflict message"
    - "Conflict message shows who currently owns the task"
    - "User can refresh page to retry after conflict"
    - "Concurrent task assignment claims result in one success, one clear error"
    - "Error handler offers retry button when conflict is detected"
  artifacts:
    - path: "backend/workorder/exceptions.py"
      provides: "TaskConflictError exception"
      contains: "class TaskConflictError"
    - path: "backend/workorder/services/task_assignment.py"
      provides: "Enhanced conflict detection in claim and assign methods"
      contains: "TaskConflictError"
    - path: "frontend/src/utils/errorHandler.js"
      provides: "Conflict error handling with retry capability"
      contains: "isConflictError"
  key_links:
    - from: "backend/workorder/services/task_assignment.py"
      to: "backend/workorder/exceptions.py"
      via: "TaskConflictError exception"
      pattern: "TaskConflictError"
    - from: "frontend/src/utils/errorHandler.js"
      to: "backend/workorder/views/work_order_tasks/task_main.py"
      via: "409 status code detection"
      pattern: "409|status.*409|conflict"
---

<objective>
Add concurrency conflict detection and user-friendly error handling

This plan enhances the task assignment and claiming operations with robust concurrency conflict detection. When two users attempt to modify the same task simultaneously, the system detects the conflict and returns a clear error message indicating what happened and who now owns the task. Frontend error handlers can detect these conflicts and offer retry options.

Purpose: Provide graceful handling of concurrent task modifications with clear user feedback
Output: Complete error handling system for assignment/claim conflicts
</objective>

<execution_context>
@/home/chenjiaxing/.claude/get-shit-done/workflows/execute-plan.md
@/home/chenjiaxing/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/workorder/exceptions.py
@backend/workorder/services/task_assignment.py
@backend/workorder/models/core.py
@.planning/phases/04-Task-Assignment-Core/04-01-PLAN.md
@.planning/phases/04-Task-Assignment-Core/04-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Add TaskConflictError exception and enhance conflict detection</name>
  <files>backend/workorder/exceptions.py</files>
  <action>
1. Add TaskConflictError to `backend/workorder/exceptions.py` after ConflictError:

```python
class TaskConflictError(ConflictError):
    """
    任务冲突错误

    用于任务分配/认领时的并发冲突检测。
    当两个用户同时尝试分配或认领同一任务时抛出。
    """

    status_code = 409
    default_detail = _('该任务正在被其他用户操作，请刷新后重试')
    default_code = 'task_conflict'

    def __init__(self, detail=None, current_owner=None, task_id=None):
        """
        Args:
            detail: 错误详情
            current_owner: 当前任务拥有者信息
            task_id: 任务ID
        """
        if detail is None:
            detail = self.default_detail
        super().__init__(detail)
        self.current_owner = current_owner
        self.task_id = task_id

    def __str__(self):
        if self.current_owner:
            return f"任务冲突：该任务已被 {self.current_owner} 分配"
        return str(self.default_detail)
```

2. Update `backend/workorder/services/task_assignment.py` to enhance conflict detection in both assign_to_operator and claim_task methods.

For `assign_to_operator`, add additional validation before assignment:

```python
        # After task validation, add concurrency check:

        # 并发冲突检测：检查任务是否刚被其他人分配
        # (使用 select_for_update 已经保证原子性，这里检查是否需要友好提示)
        if task.assigned_operator and task.assigned_operator_id != operator_id:
            logger.warning(
                f"分配冲突：任务 {task_id} 在处理过程中被分配给 "
                f"{task.assigned_operator.username}，请求分配给 {operator.username}"
            )
            # 注意：由于 select_for_update，这里实际上不会发生
            # 这是防御性代码，未来如果去掉行锁时仍有保护
```

For `claim_task`, enhance the already_assigned check to throw TaskConflictError:

Update the section that checks if task is already claimed:

```python
        # Replace the existing check with:

        # 检查任务是否已被其他操作员认领
        if task.assigned_operator:
            # 如果是被自己认领的，允许更新
            if task.assigned_operator.id == operator.id:
                return {
                    'task_id': task.id,
                    'assigned_operator': {
                        'id': operator.id,
                        'username': operator.username,
                        'first_name': operator.first_name,
                        'last_name': operator.last_name
                    },
                    'already_claimed': True,
                    'message': '您已经认领了该任务'
                }

            # 被其他人认领 - 使用特定的冲突错误
            from ..exceptions import TaskConflictError
            raise TaskConflictError(
                detail=f"该任务已被 {task.assigned_operator.username} 认领，无法重复认领",
                current_owner=task.assigned_operator.username,
                task_id=task.id
            )
```

3. Also add a utility method for retry suggestions:

```python
    @staticmethod
    def get_retry_suggestion(error: Exception) -> Dict[str, Any]:
        """根据错误类型提供重试建议

        Args:
            error: 捕获的异常

        Returns:
            Dict: 包含重试建议的字典
        """
        from ..exceptions import TaskConflictError

        if isinstance(error, TaskConflictError):
            return {
                'can_retry': True,
                'suggestion': '刷新页面后重试',
                'current_owner': getattr(error, 'current_owner', None),
                'action_text': '刷新页面'
            }

        if isinstance(error, PermissionDeniedError):
            return {
                'can_retry': False,
                'suggestion': '您没有权限执行此操作',
                'action_text': '联系管理员'
            }

        if isinstance(error, BusinessLogicError):
            return {
                'can_retry': False,
                'suggestion': str(error),
                'action_text': '确定'
            }

        return {
            'can_retry': False,
            'suggestion': '操作失败，请稍后重试',
            'action_text': '重试'
        }
```
  </action>
  <verify>
grep -A 5 "class TaskConflictError" backend/workorder/exceptions.py | grep -E "(current_owner|task_id)"
grep "TaskConflictError" backend/workorder/services/task_assignment.py
  </verify>
  <done>Conflict error class added and claim_task uses it for concurrent claims</done>
</task>

<task type="auto">
  <name>Update viewset to return 409 status for conflict errors</name>
  <files>backend/workorder/views/work_order_tasks/task_main.py</files>
  <action>
Update both assign and claim actions in `backend/workorder/views/work_order_tasks/task_main.py` to handle TaskConflictError:

Update the exception handling section in both methods:

For assign action, replace the existing exception handling with:

```python
        except (PermissionDeniedError, BusinessLogicError) as e:
            # 确定状态码
            status_code = status.HTTP_403_FORBIDDEN
            if hasattr(e, 'status_code'):
                status_code = e.status_code

            # 构建错误响应
            error_response = {
                'detail': str(e),
                'code': e.default_code
            }

            # 如果是冲突错误，添加额外信息
            if hasattr(e, 'current_owner') and e.current_owner:
                error_response['current_owner'] = e.current_owner
            if hasattr(e, 'task_id') and e.task_id:
                error_response['task_id'] = e.task_id

            # 添加重试建议
            from workorder.services.task_assignment import TaskAssignmentService
            retry_info = TaskAssignmentService.get_retry_suggestion(e)
            error_response['retry'] = retry_info

            return Response(error_response, status=status_code)

        except Exception as e:
            logger = logging.getLogger(__name__)
            logger.error(f"任务分配失败: {str(e)}")
            return Response({
                'detail': '任务分配失败，请稍后重试',
                'error': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
```

For claim action, replace the existing exception handling with:

```python
        except BusinessLogicError as e:
            # 确定状态码
            status_code = status.HTTP_400_BAD_REQUEST
            if hasattr(e, 'status_code'):
                status_code = e.status_code

            # 构建错误响应
            error_response = {
                'detail': str(e),
                'code': e.default_code if hasattr(e, 'default_code') else 'business_logic_error'
            }

            # 如果是冲突错误，添加额外信息
            if hasattr(e, 'current_owner') and e.current_owner:
                error_response['current_owner'] = e.current_owner
            if hasattr(e, 'task_id') and e.task_id:
                error_response['task_id'] = e.task_id

            # 添加重试建议
            from workorder.services.task_assignment import TaskAssignmentService
            retry_info = TaskAssignmentService.get_retry_suggestion(e)
            error_response['retry'] = retry_info

            return Response(error_response, status=status_code)

        except Exception as e:
            logger = logging.getLogger(__name__)
            logger.error(f"任务认领失败: {str(e)}")
            return Response({
                'detail': '任务认领失败，请稍后重试',
                'error': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
```
  </action>
  <verify>ViewSet exception handling checks for status_code attribute and includes retry info</verify>
  <done>Conflict errors return 409 status with retry information</done>
</task>

<task type="auto">
  <name>Add conflict error handling to frontend errorHandler</name>
  <files>frontend/src/utils/errorHandler.js</files>
  <action>
Update `frontend/src/utils/errorHandler.js` to add conflict detection:

Add the following methods to the ErrorHandler class (or create the file if it doesn't exist):

```javascript
/**
 * 统一错误处理工具
 */
class ErrorHandler {
  /**
   * 判断是否为任务冲突错误
   * @param {Object} error - 错误对象
   * @returns {Boolean}
   */
  static isConflictError(error) {
    if (!error) return false

    // 检查响应状态码
    if (error.response?.status === 409) {
      return true
    }

    // 检查错误代码
    if (error.response?.data?.code === 'task_conflict') {
      return true
    }

    return false
  }

  /**
   * 判断是否为权限错误
   * @param {Object} error - 错误对象
   * @returns {Boolean}
   */
  static isPermissionError(error) {
    if (!error) return false
    return error.response?.status === 403
  }

  /**
   * 处理任务分配/认领错误
   * @param {Object} error - 错误对象
   * @param {Object} options - 选项
   * @returns {Object} 处理后的错误信息
   */
  static handleTaskError(error, options = {}) {
    const { onConflict = null, onPermission = null, onOther = null } = options

    if (this.isConflictError(error)) {
      const conflictData = {
        type: 'conflict',
        message: error.response?.data?.detail || '该任务正在被其他用户操作',
        currentOwner: error.response?.data?.current_owner,
        taskId: error.response?.data?.task_id,
        retry: error.response?.data?.retry
      }

      if (onConflict) {
        onConflict(conflictData)
      } else {
        this.showConflictMessage(conflictData)
      }

      return conflictData
    }

    if (this.isPermissionError(error)) {
      const permData = {
        type: 'permission',
        message: error.response?.data?.detail || '您没有权限执行此操作'
      }

      if (onPermission) {
        onPermission(permData)
      } else {
        this.showMessage(permData.message, 'error')
      }

      return permData
    }

    // 其他错误
    const otherData = {
      type: 'other',
      message: error.response?.data?.detail || error.message || '操作失败'
    }

    if (onOther) {
      onOther(otherData)
    } else {
      this.showMessage(otherData.message, 'error')
    }

    return otherData
  }

  /**
   * 显示冲突错误消息（带重试选项）
   * @param {Object} conflictData - 冲突数据
   */
  static showConflictMessage(conflictData) {
    // 使用 Element UI 的 MessageBox 显示冲突和重试选项
    const { currentOwner, retry } = conflictData

    let message = conflictData.message
    if (currentOwner) {
      message += `\n\n当前操作人：${currentOwner}`
    }

    // 显示确认对话框
    this.$confirm?.(message, '任务冲突', {
      confirmButtonText: retry?.action_text || '刷新页面',
      cancelButtonText: '取消',
      type: 'warning'
    }).then(() => {
      // 用户点击重试 - 刷新页面
      location.reload()
    }).catch(() => {
      // 用户取消
    })
  }

  /**
   * 显示消息（使用 Element UI 的 Message）
   * @param {String} message - 消息内容
   * @param {String} type - 消息类型
   */
  static showMessage(message, type = 'info') {
    // 使用 Element UI Message
    if (typeof window !== 'undefined' && window.ELEMENT && window.ELEMENT.Message) {
      window.ELEMENT.Message({
        message,
        type,
        duration: 3000
      })
    } else {
      console.log(`[${type.toUpperCase()}] ${message}`)
    }
  }

  /**
   * 显示成功消息
   * @param {String} message - 消息内容
   */
  static showSuccess(message) {
    this.showMessage(message, 'success')
  }

  /**
   * 显示错误消息
   * @param {String} message - 消息内容
   */
  static showError(message) {
    this.showMessage(message, 'error')
  }

  /**
   * 显示警告消息
   * @param {String} message - 消息内容
   */
  static showWarning(message) {
    this.showMessage(message, 'warning')
  }
}

export default ErrorHandler
```

Also add a helper in the API module `frontend/src/api/modules/workorder-task.js` to use this handler:

Update the existing methods to use error handler:

```javascript
import ErrorHandler from '@/utils/errorHandler'

// In the class:

  // 带错误处理的任务认领
  async claimTaskWithErrorHandling(id, data) {
    try {
      const response = await this.claimTask(id, data)
      ErrorHandler.showSuccess('任务认领成功')
      return response
    } catch (error) {
      const handled = ErrorHandler.handleTaskError(error, {
        onConflict: (conflictData) => {
          // 自定义冲突处理
          ErrorHandler.showConflictMessage(conflictData)
        }
      })
      throw handled // 重新抛出以便调用者处理
    }
  }

  // 带错误处理的任务分配
  async assignToOperatorWithErrorHandling(id, data) {
    try {
      const response = await this.assignToOperator(id, data)
      ErrorHandler.showSuccess('任务分配成功')
      return response
    } catch (error) {
      const handled = ErrorHandler.handleTaskError(error, {
        onConflict: (conflictData) => {
          ErrorHandler.showConflictMessage(conflictData)
        }
      })
      throw handled
    }
  }
```
  </action>
  <verify>errorHandler.js contains isConflictError and handleTaskError methods</verify>
  <done>Frontend conflict handling added with retry option</done>
</task>

</tasks>

<verification>
1. TaskConflictError exception exists with current_owner and task_id attributes
2. claim_task raises TaskConflictError when task already claimed
3. ViewSet returns 409 status for TaskConflictError
4. Error response includes retry information (can_retry, suggestion, action_text)
5. Frontend ErrorHandler detects 409 status and task_conflict code
6. Frontend shows conflict message with refresh/retry option
7. Non-conflict errors still show appropriate messages
</verification>

<success_criteria>
1. Two simultaneous claims to same task result in one success, one 409 error
2. 409 error response includes current_owner field showing who claimed the task
3. Frontend displays user-friendly conflict dialog with retry button
4. Clicking retry button refreshes the page to see current state
5. Permission errors still return 403 without conflict handling
6. Generic errors still return 400/500 as appropriate
</success_criteria>

<output>
After completion, create `.planning/phases/04-Task-Assignment-Core/04-03-SUMMARY.md`
</output>
