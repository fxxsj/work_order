---
phase: 02-Task-Data-Consistency
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/workorder/services/task_sync_service.py
  - backend/workorder/models/core.py
  - backend/workorder/views/work_orders.py
  - backend/workorder/urls.py
autonomous: true

must_haves:
  truths:
    - "User modifies work order processes and receives preview of sync changes before confirmation"
    - "System adds new tasks for added processes and removes tasks for deleted processes"
    - "Sync only affects draft tasks - formal tasks remain untouched"
    - "Process changes never leave orphaned or duplicate tasks"
    - "Two-step API prevents accidental data loss (preview then confirm)"
  artifacts:
    - path: "backend/workorder/services/task_sync_service.py"
      provides: "TaskSyncService class with preview_sync and execute_sync methods"
      exports: ["TaskSyncService.preview_sync", "TaskSyncService.execute_sync"]
    - path: "backend/workorder/views/work_orders.py"
      provides: "Sync preview and confirm API endpoints"
      contains: "@action(detail=True, methods=['post']) def sync_tasks_preview"
    - path: "backend/workorder/urls.py"
      provides: "URL routing for sync endpoints"
      contains: "sync-tasks-preview"
  key_links:
    - from: "backend/workorder/views/work_orders.py:sync_tasks_preview"
      to: "backend/workorder/services/task_sync_service.py:TaskSyncService.preview_sync"
      via: "service method call for preview calculation"
      pattern: "TaskSyncService\\.preview_sync\\("
    - from: "backend/workorder/views/work_orders.py:sync_tasks_execute"
      to: "backend/workorder/services/task_sync_service.py:TaskSyncService.execute_sync"
      via: "service method call for sync execution"
      pattern: "TaskSyncService\\.execute_sync\\("
    - from: "backend/workorder/services/task_sync_service.py:TaskSyncService.execute_sync"
      to: "backend/workorder/services/task_generation.py:DraftTaskGenerationService"
      via: "reuse existing task generation logic"
      pattern: "DraftTaskGenerationService\\.build_task_objects"
---

<objective>
Build differential update algorithm to sync tasks with process changes

Purpose: When work order processes are modified, the system must synchronize draft tasks without creating orphans or duplicates. A two-step process (preview + confirm) prevents accidental data loss.

Output: TaskSyncService with preview_sync and execute_sync methods, exposed via REST API endpoints
</objective>

<execution_context>
@/home/chenjiaxing/.claude/get-shit-done/workflows/execute-plan.md
@/home/chenjiaxing/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-Task-Data-Consistency/02-RESEARCH.md
@.planning/phases/01-draft-task-foundation/01-02-SUMMARY.md
@backend/workorder/services/task_generation.py
@backend/workorder/models/core.py
@backend/workorder/views/work_orders.py
</context>

<tasks>

<task type="auto">
  <name>Create TaskSyncService with preview and sync methods</name>
  <files>backend/workorder/services/task_sync_service.py</files>
  <action>
    Create new file backend/workorder/services/task_sync_service.py with TaskSyncService class:

    The service should implement three-way synchronization algorithm:

    1. Import required modules:
       - from django.db import transaction
       - from workorder.models.core import WorkOrder, WorkOrderProcess, WorkOrderTask
       - from workorder.services.task_generation import DraftTaskGenerationService

    2. Create TaskSyncService class with two static methods:

    **preview_sync(work_order, old_process_ids, new_process_ids):**
       - Calculate set differences using Python sets
       - old_set = set(old_process_ids), new_set = set(new_process_ids)
       - removed = old_set - new_set (processes to remove)
       - added = new_set - old_set (processes to add)
       - Query count of draft tasks that would be removed
       - Estimate count of tasks to be added (based on process types)
       - Return dict: {tasks_to_remove, tasks_to_add, removed_process_ids, added_process_ids, affected}
       - Does NOT modify database

    **execute_sync(work_order, old_process_ids, new_process_ids):**
       - Decorate with @transaction.atomic for atomic operation
       - Lock work_order using select_for_update() to prevent concurrent modifications
       - Call preview_sync first to calculate changes
       - Remove draft tasks for deleted processes:
         * WorkOrderTask.objects.filter(work_order_process__in=removed_ids, status='draft').delete()
       - Generate draft tasks for added processes:
         * For each process_id in added_ids: get WorkOrderProcess, call DraftTaskGenerationService.build_task_objects
         * Use bulk_create with batch_size=100
       - Return dict: {deleted_count, added_count, message}

    Key implementation details from RESEARCH.md:
    - Use set() operations for O(1) difference calculations
    - Filter by status='draft' to avoid affecting formal tasks
    - Use select_for_update() to prevent race conditions
    - Wrap all operations in transaction.atomic()
    - Reuse DraftTaskGenerationService.build_task_objects for consistency
  </action>
  <verify>test -f backend/workorder/services/task_sync_service.py && grep -c "class TaskSyncService" backend/workorder/services/task_sync_service.py</verify>
  <done>TaskSyncService class created with preview_sync (read-only) and execute_sync (atomic) methods</done>
</task>

<task type="auto">
  <name>Add sync preview API endpoint</name>
  <files>backend/workorder/views/work_orders.py backend/workorder/urls.py</files>
  <action>
    Add sync preview API endpoint to WorkOrderViewSet:

    1. In backend/workorder/views/work_orders.py:
       - Import TaskSyncService from services.task_sync_service
       - Add @action decorator method to WorkOrderViewSet:
         ```python
         @action(detail=True, methods=['post'])
         def sync_tasks_preview(self, request, pk=None):
             '''Preview task sync changes without executing'''
             work_order = self.get_object()
             new_process_ids = request.data.get('process_ids', [])
             old_process_ids = list(work_order.order_processes.values_list('id', flat=True))

             # Validate work order is not already approved
             if work_order.approval_status == 'approved':
                 return Response(
                     {'error': '已审核的施工单不能修改工序'},
                     status=400
                 )

             preview = TaskSyncService.preview_sync(work_order, old_process_ids, new_process_ids)
             return Response({'preview': preview})
         ```

    2. In backend/workorder/urls.py:
       - The router should auto-register the action as: workorders/{id}/sync_tasks_preview/
       - Verify router configuration includes ViewSet actions

    The preview endpoint should:
    - Accept POST with {process_ids: [id1, id2, ...]} in request body
    - Return preview showing what would change (no modifications)
    - Reject if work order is already approved
    - Include counts of tasks to add/remove
  </action>
  <verify>grep -n "sync_tasks_preview" backend/workorder/views/work_orders.py</verify>
  <done>Sync preview API endpoint exists at POST /api/workorders/{id}/sync_tasks_preview/</done>
</task>

<task type="auto">
  <name>Add sync execute API endpoint</name>
  <files>backend/workorder/views/work_orders.py</files>
  <action>
    Add sync execute API endpoint to WorkOrderViewSet:

    In backend/workorder/views/work_orders.py, add another @action method:
    ```python
    @action(detail=True, methods=['post'])
    def sync_tasks_execute(self, request, pk=None):
        '''Execute task sync after user confirmation'''
        work_order = self.get_object()
        new_process_ids = request.data.get('process_ids', [])
        old_process_ids = list(work_order.order_processes.values_list('id', flat=True))

        # Validate work order is not already approved
        if work_order.approval_status == 'approved':
            return Response(
                {'error': '已审核的施工单不能同步任务'},
                status=400
            )

        # Require confirmation flag
        if not request.data.get('confirmed'):
            return Response(
                {'error': '需要确认后才能执行同步'},
                status=400
            )

        # Execute sync
        result = TaskSyncService.execute_sync(work_order, old_process_ids, new_process_ids)

        return Response({
            'result': result,
            'message': result.get('message', '任务同步完成')
        })
    ```

    The execute endpoint should:
    - Accept POST with {process_ids: [...], confirmed: true}
    - Require confirmed=true flag to prevent accidental execution
    - Call TaskSyncService.execute_sync with transaction.atomic
    - Return counts of added/removed tasks
    - Reject if work order is already approved
  </action>
  <verify>grep -n "sync_tasks_execute" backend/workorder/views/work_orders.py</verify>
  <done>Sync execute API endpoint exists at POST /api/workorders/{id}/sync_tasks_execute/ with confirmed flag requirement</done>
</task>

<task type="auto">
  <name>Integrate sync prompt into work order process update flow</name>
  <files>backend/workorder/serializers/core.py backend/workorder/views/work_orders.py</files>
  <action>
    Add sync prompt trigger when work order processes are modified:

    1. In backend/workorder/serializers/core.py:
       - Find WorkOrderCreateUpdateSerializer (around line 852)
       - Update update() method to detect process changes
       - After saving processes, check if process list changed
       - If changed and work_order.approval_status != 'approved':
         * Set a flag in response: suggests_task_sync: true
         * Include old_process_ids and new_process_ids in response

    2. Alternative approach (if serializer integration is complex):
       - Add a separate endpoint check: @action(detail=True, methods=['get']) def check_sync_needed
       - Returns {sync_needed: bool, current_processes: [...]}
       - Frontend calls this before and after process updates

    Implementation choice: Add check_sync_needed endpoint for cleaner separation of concerns.

    In WorkOrderViewSet:
    ```python
    @action(detail=True, methods=['get'])
    def check_sync_needed(self, request, pk=None):
        '''Check if task sync is needed after process changes'''
        work_order = self.get_object()
        current_process_ids = list(work_order.order_processes.values_list('id', flat=True))
        stored_process_ids = request.query_params.get('process_ids', '').split(',')
        stored_process_ids = [int(id) for id in stored_process_ids if id]

        has_changes = set(current_process_ids) != set(stored_process_ids)

        return Response({
            'sync_needed': has_changes and work_order.approval_status != 'approved',
            'current_process_ids': current_process_ids,
            'can_sync': work_order.approval_status != 'approved'
        })
    ```

    This allows frontend to detect changes and prompt user to sync.
  </action>
  <verify>grep -n "check_sync_needed" backend/workorder/views/work_orders.py</verify>
  <done>Frontend can detect process changes and prompt user for task sync confirmation</done>
</task>

</tasks>

<verification>
After completion, verify:
1. Python shell: from workorder.services.task_sync_service import TaskSyncService; assert callable(TaskSyncService.preview_sync)
2. Python shell: from workorder.services.task_sync_service import TaskSyncService; assert callable(TaskSyncService.execute_sync)
3. API test: POST /api/workorders/{id}/sync_tasks_preview/ with {process_ids: [...]} returns preview dict
4. API test: POST /api/workorders/{id}/sync_tasks_execute/ with {process_ids: [...], confirmed: true} executes sync
5. Integration test: Add process -> preview shows tasks to add -> execute -> tasks created
6. Integration test: Remove process -> preview shows tasks to remove -> execute -> draft tasks deleted
7. Edge case: Try to sync approved work order -> returns 400 error
8. Edge case: Remove process with formal tasks -> only draft tasks deleted, formal tasks remain
</verification>

<success_criteria>
- TaskSyncService created with preview_sync and execute_sync methods
- Sync preview API returns changes without modifying database
- Sync execute API applies changes atomically after confirmation
- Only draft tasks are affected by sync operations
- Approved work orders cannot sync (returns 400 error)
- No orphaned or duplicate tasks after sync operations
</success_criteria>

<output>
After completion, create `.planning/phases/02-Task-Data-Consistency/02-01-SUMMARY.md`
</output>
