---
phase: 08-Real-time-Notifications
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - backend/workorder/services/realtime_notification.py
  - backend/workorder/models/system.py
  - backend/workorder/services/notification_triggers.py
  - backend/workorder/views/work_order_tasks/__init__.py
autonomous: true

must_haves:
  truths:
    - "NotificationConsumer connects authenticated users to their personal notification channel"
    - "Task assignment triggers WebSocket notification to assigned operator"
    - "Task completion triggers WebSocket notification to supervisor"
    - "Notifications are saved to database with is_read=False"
    - "WebSocket connection rejects unauthenticated users"
    - "Channel layer broadcasts notifications to user-specific groups"
  artifacts:
    - path: "backend/workorder/services/realtime_notification.py"
      provides: "WebSocket consumer and notification service"
      contains: "NotificationConsumer", "RealtimeNotificationService"
    - path: "backend/workorder/models/system.py"
      provides: "Notification model for persistence"
      contains: "class Notification"
    - path: "backend/workorder/services/notification_triggers.py"
      provides: "Signal handlers for task events"
      contains: "task_assigned_handler", "task_status_change_handler"
  key_links:
    - from: "backend/workorder/services/notification_triggers.py"
      to: "backend/workorder/services/realtime_notification.py"
      via: "notification_service.send_notification"
      pattern: "notification_service\\.(send_notification|notify_task_assignment)"
    - from: "NotificationConsumer.connect"
      to: "channel_layer.group_add"
      via: "WebSocket connection handshake"
      pattern: "group_add.*user_.*_notifications"
    - from: "task assigned signal"
      to: "assigned operator's WebSocket channel"
      via: "notification_service._send_websocket_notification"
      pattern: "task_assigned.*channel_layer"
---

<objective>
Build WebSocket consumers for task event broadcasting to enable real-time delivery of task assignment and completion notifications.

Purpose: Implement the notification delivery mechanism that pushes task events (assigned, completed) to connected users in real-time via WebSocket, eliminating the need for polling and providing instant feedback.

Output: Fully functional WebSocket consumer with authenticated connections, task event signal handlers, and notification broadcasting to relevant users.
</objective>

<execution_context>
@/home/chenjiaxing/.claude/get-shit-done/workflows/execute-plan.md
@/home/chenjiaxing/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-Real-time-Notifications/08-CONTEXT.md
@.planning/phases/08-Real-time-Notifications/08-01-PLAN.md
@backend/workorder/services/realtime_notification.py
@backend/workorder/models/system.py
@backend/workorder/services/notification_triggers.py
@backend/workorder/models/core.py
</context>

<tasks>

<task type="auto">
  <name>Update Notification model with is_sent and data fields</name>
  <files>backend/workorder/models/system.py</files>
  <action>
    Review and update the Notification model in backend/workorder/models/system.py:

    The Notification model already exists with:
    - recipient, notification_type, title, content, priority
    - Related objects: work_order, work_order_process, task, purchase_order
    - Status: is_read, read_at
    - Timestamps: created_at, expires_at

    Add/verify these fields if missing:
    1. `is_sent = models.BooleanField('已发送', default=False)` - tracks if notification was delivered via WebSocket
    2. `data = models.JSONField('扩展数据', null=True, blank=True)` - stores additional notification data

    These fields are needed for:
    - Tracking WebSocket delivery status
    - Storing structured data for frontend consumption

    Also verify indexes include:
    - (recipient, is_read, -created_at) for querying user's unread notifications
    - (notification_type, -created_at) for filtering by type

    DO NOT create migrations - just update the model definition.
  </action>
  <verify>grep -E "is_sent|data.*JSONField" backend/workorder/models/system.py</verify>
  <done>Notification model has is_sent field and data JSONField for structured notification payload</done>
</task>

<task type="auto">
  <name>Implement NotificationConsumer with authentication and heartbeat</name>
  <files>backend/workorder/services/realtime_notification.py</files>
  <action>
    Update the NotificationConsumer class in backend/workorder/services/realtime_notification.py:

    The existing consumer has basic structure. Enhance it with:

    1. **Authentication check**: Reject unauthenticated connections
    2. **User-specific channel naming**: Use `user_{user_id}_notifications`
    3. **Heartbeat mechanism**: Send periodic ping to detect stale connections
    4. **Disconnect handler**: Clean up channel membership
    5. **Connection state tracking**: Log connections for monitoring

    Enhanced consumer structure:
    ```python
    class NotificationConsumer(AsyncWebsocketConsumer):
        """WebSocket通知消费者"""

        async def connect(self):
            """建立WebSocket连接"""
            user = self.scope.get("user")

            # 拒绝未认证用户
            if user is None or not user.is_authenticated:
                await self.close(code=4001)
                return

            self.user_id = user.id
            self.group_name = f"user_{self.user_id}_notifications"

            # 加入用户通知组
            await self.channel_layer.group_add(
                self.group_name,
                self.channel_name
            )

            await self.accept()

            # 发送连接成功确认
            await self.send(json.dumps({
                'type': 'connection_established',
                'user_id': self.user_id,
                'timestamp': timezone.now().isoformat()
            }))

            # 记录连接日志
            logger.info(f"WebSocket连接建立: user_id={self.user_id}")

        async def disconnect(self, close_code):
            """断开WebSocket连接"""
            if hasattr(self, 'group_name'):
                await self.channel_layer.group_discard(
                    self.group_name,
                    self.channel_name
                )
                logger.info(f"WebSocket连接断开: user_id={self.user_id}, code={close_code}")

        async def notification_message(self, event):
            """处理通知消息"""
            await self.send(text_data=json.dumps({
                'type': 'notification',
                'data': event.get('notification', {})
            }))

        async def heartbeat_message(self, event):
            """处理心跳消息"""
            await self.send(text_data=json.dumps({
                'type': 'heartbeat',
                'timestamp': timezone.now().isoformat()
            }))
    ```

    Key improvements over existing:
    - Explicit authentication check with rejection
    - Connection confirmation message
    - Proper logging
    - Heartbeat support
  </action>
  <verify>grep -E "async def connect|is_authenticated|async def disconnect|heartbeat" backend/workorder/services/realtime_notification.py</verify>
  <done>NotificationConsumer has authentication check, proper connection handling, heartbeat support, and logging</done>
</task>

<task type="auto">
  <name>Update notification service with task-specific broadcast methods</name>
  <files>backend/workorder/services/realtime_notification.py</files>
  <action>
    Enhance RealtimeNotificationService in backend/workorder/services/realtime_notification.py:

    Add dedicated methods for task events as per context decisions:

    1. **notify_task_assigned**: Notify operator when task is assigned to them
    2. **notify_task_completed**: Notify supervisor when operator completes task
    3. **notify_task_claimed**: Notify department when operator claims task
    4. **_get_department_members**: Helper to get all users in a department

    Implementation pattern:
    ```python
    def notify_task_assigned(self, task, assigned_operator, assigned_by=None):
        """通知任务分配"""
        recipients = [assigned_operator]

        # 通知分配者所在部门的其他成员（根据上下文：部门成员可见）
        if task.assigned_department:
            dept_members = self._get_department_members(task.assigned_department)
            recipients.extend(dept_members)

        # 去重
        recipients = list(set(recipients))

        self.send_notification(
            event_type=NotificationEvent.TASK_ASSIGNED,
            recipients=recipients,
            data={
                'title': '新任务分配',
                'message': f'您有新的任务: {task.work_content}',
                'task_id': task.id,
                'workorder_id': task.work_order.id,
                'workorder_number': task.work_order.order_number,
                'process_code': task.process_code,
                'process_name': task.process_code,  # Will be resolved to process name
                'assigned_by': assigned_by.username if assigned_by else '系统',
                'quantity': task.quantity,
                'priority': task.work_order.priority,
                'deadline': task.deadline.isoformat() if task.deadline else None,
            },
            priority=self._map_priority(task.work_order.priority),
            channels=[NotificationChannel.WEBSOCKET, NotificationChannel.IN_APP]
        )

    def notify_task_completed(self, task, completed_by):
        """通知任务完成"""
        recipients = []

        # 通知主管
        supervisors = self._get_supervisors()
        recipients.extend(supervisors)

        # 通知施工单创建者
        if task.work_order.created_by:
            recipients.append(task.work_order.created_by)

        recipients = list(set(recipients))

        self.send_notification(
            event_type=NotificationEvent.TASK_COMPLETED,
            recipients=recipients,
            data={
                'title': '任务完成',
                'message': f'任务 "{task.work_content}" 已完成',
                'task_id': task.id,
                'workorder_id': task.work_order.id,
                'workorder_number': task.work_order.order_number,
                'completed_by': completed_by.username if completed_by else '系统',
                'completed_at': timezone.now().isoformat(),
                'process_code': task.process_code,
            },
            priority=NotificationPriority.NORMAL,
            channels=[NotificationChannel.WEBSOCKET, NotificationChannel.IN_APP]
        )

    def _get_department_members(self, department):
        """获取部门成员"""
        try:
            from ..models.system import UserProfile
            return User.objects.filter(
                profile__departments=department,
                is_active=True
            ).distinct()
        except Exception:
            return []

    def _map_priority(self, workorder_priority):
        """映射施工单优先级到通知优先级"""
        priority_map = {
            'urgent': NotificationPriority.URGENT,
            'high': NotificationPriority.HIGH,
            'normal': NotificationPriority.NORMAL,
            'low': NotificationPriority.LOW,
        }
        return priority_map.get(workorder_priority, NotificationPriority.NORMAL)
    ```

    Note: The existing notify_task_assignment exists, update it to match the new signature
    and add department member notifications.
  </action>
  <verify>grep -E "notify_task_assigned|notify_task_completed|_get_department_members|_map_priority" backend/workorder/services/realtime_notification.py</verify>
  <done>Service has task_assigned and task_completed notification methods with department member support and priority mapping</done>
</task>

<task type="auto">
  <name>Create signal handlers for task assignment events</name>
  <files>backend/workorder/services/notification_triggers.py</files>
  <action>
    Review and update signal handlers in backend/workorder/services/notification_triggers.py:

    The file already has task_assigned_handler and task_status_change_handler.
    Update them to work with the new task model fields (assigned_operator, assigned_department).

    Key updates needed:

    1. **task_assigned_handler**: Update to use assigned_operator instead of assigned_to
       ```python
       @receiver(post_save, sender=WorkOrderTask)
       def task_assigned_handler(sender, instance, created, **kwargs):
           """任务分配时触发通知"""
           # Check if operator was assigned (not just department)
           if instance.assigned_operator:
               notification_service.notify_task_assigned(
                   task=instance,
                   assigned_operator=instance.assigned_operator,
                   assigned_by=instance.updated_by or instance.created_by
               )
       ```

    2. **Add task_claimed_handler**: New handler for operator self-claiming
       ```python
       @receiver(post_save, sender=WorkOrderTask)
       def task_claimed_handler(sender, instance, created, **kwargs):
           """操作员认领任务时触发通知"""
           if not created and instance.assigned_operator:
               # Get old instance to check if this is a claim action
               try:
                   old_instance = WorkOrderTask.objects.get(pk=instance.pk)
                   if old_instance.assigned_operator is None and instance.assigned_operator:
                       # Operator just claimed this task
                       notification_service.notify_task_claimed(
                           task=instance,
                           claimed_by=instance.assigned_operator
                       )
               except WorkOrderTask.DoesNotExist:
                   pass
       ```

    3. **Update task_status_change_handler**: Ensure it triggers completion notification
       ```python
       @receiver(pre_save, sender=WorkOrderTask)
       def task_status_change_handler(sender, instance, **kwargs):
           """任务状态变更时触发通知"""
           if instance.pk:
               try:
                   old_instance = WorkOrderTask.objects.get(pk=instance.pk)
                   old_status = old_instance.status
                   new_status = instance.status

                   if old_status != new_status and new_status == 'completed':
                       # 任务完成 - 通知主管和创建者
                       notification_service.notify_task_completed(
                           task=instance,
                           completed_by=instance.assigned_operator or instance.updated_by
                       )
               except WorkOrderTask.DoesNotExist:
                   pass
       ```

    Ensure imports at top of file include:
    - WorkOrderTask from models.core
    - notification_service from realtime_notification
  </action>
  <verify>grep -E "task_assigned_handler|task_claimed_handler|task_status_change_handler|assigned_operator" backend/workorder/services/notification_triggers.py</verify>
  <done>Signal handlers trigger notifications for task assignment, claiming, and completion using assigned_operator field</done>
</task>

<task type="auto">
  <name>Add notification endpoints for task event triggers</name>
  <files>backend/workorder/views/work_order_tasks/__init__.py</files>
  <action>
    Check backend/workorder/views/work_order_tasks/__init__.py for the assign/complete action endpoints.

    The task assignment and completion actions should trigger notifications via:
    ```python
    from ..services.realtime_notification import notification_service

    # In assign action:
    @action(detail=True, methods=['post'])
    def assign(self, request, pk=None):
        # ... assignment logic ...
        # Trigger notification
        notification_service.notify_task_assigned(
            task=task,
            assigned_operator=operator,
            assigned_by=request.user
        )

    # In complete action:
    @action(detail=True, methods=['post'])
    def complete(self, request, pk=None):
        # ... completion logic ...
        # Trigger notification
        notification_service.notify_task_completed(
            task=task,
            completed_by=request.user
        )
    ```

    Find the WorkOrderTask viewset and verify that assign and complete actions
    call the notification service after successful operation.

    If the viewset doesn't exist or doesn't have these actions, note this in summary
    for the next plan to add API triggers.

    Do NOT add new endpoints - only verify existing ones trigger notifications.
  </action>
  <verify>grep -r "notify_task_assigned\|notify_task_completed" backend/workorder/views/</verify>
  <done>Task assign and complete endpoints trigger notifications via notification_service</done>
</task>

</tasks>

<verification>
After completing all tasks, verify the notification broadcasting:

1. Check that NotificationConsumer rejects unauthenticated connections (close code 4001)
2. Verify signal handlers are registered (check imports in models.__init__)
3. Test that task assignment triggers notification_service.notify_task_assigned
4. Test that task completion triggers notification_service.notify_task_completed
5. Verify WebSocket broadcast uses correct group name (user_{user_id}_notifications)
6. Confirm notification data includes all required fields (task_id, workorder_number, process_name, etc.)

Run with Django Channels test server:
```bash
python manage.py runserver
```
And verify WebSocket handshake succeeds at ws://localhost:8000/ws/notifications/
</verification>

<success_criteria>
1. WebSocket consumer accepts only authenticated connections
2. Task assignment broadcasts to assigned operator and department members
3. Task completion broadcasts to supervisors and work order creator
4. Notifications are saved to database with is_read=False
5. Signal handlers automatically trigger on model changes
6. Channel layer correctly routes messages to user-specific channels
</success_criteria>

<output>
After completion, create `.planning/phases/08-Real-time-Notifications/08-02-SUMMARY.md` with:
- WebSocket consumer implementation details
- Signal handler configuration
- Notification event types and payloads
- Testing notes for WebSocket connection
- Any issues encountered with existing code structure
</output>
