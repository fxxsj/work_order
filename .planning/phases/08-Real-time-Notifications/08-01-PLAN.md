---
phase: 08-Real-time-Notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/requirements.txt
  - backend/config/settings.py
  - backend/config/asgi.py
  - backend/config/wsgi.py
  - backend/workorder/routing.py
autonomous: true

must_haves:
  truths:
    - "Django Channels is installed and configured in INSTALLED_APPS"
    - "ASGI application exists at config/asgi.py"
    - "Channel layer is configured (Redis in production, memory in development)"
    - "WebSocket routing is registered in the ASGI application"
    - "Daphne is specified as the ASGI server in requirements"
  artifacts:
    - path: "backend/config/asgi.py"
      provides: "ASGI application entry point for Channels"
      contains: "get_asgi_application"
    - path: "backend/config/settings.py"
      provides: "Channels configuration and channel layer settings"
      contains: "channels", "ASGI_APPLICATION", "CHANNEL_LAYERS"
    - path: "backend/requirements.txt"
      provides: "Channels dependencies"
      contains: "channels>=4.0.0", "daphne>=4.0.0", "redis>=5.0.0"
    - path: "backend/workorder/routing.py"
      provides: "WebSocket URL routing"
      contains: "websocket_urlpatterns"
  key_links:
    - from: "backend/config/asgi.py"
      to: "workorder.routing.websocket_urlpatterns"
      via: "ProtocolTypeRouter"
      pattern: "ProtocolTypeRouter.*websocket"
    - from: "backend/config/settings.py"
      to: "Redis or in-memory channel layer"
      via: "CHANNEL_LAYERS configuration"
      pattern: "CHANNEL_LAYERS.*BACKEND"
---

<objective>
Set up Django Channels with Redis for WebSocket support to enable real-time notifications.

Purpose: Establish the infrastructure foundation for WebSocket-based real-time notifications. Django Channels transforms Django from a synchronous HTTP framework into an asynchronous framework that handles WebSockets, enabling the backend to push notifications to connected clients without polling.

Output: Fully configured Channels setup with ASGI application, channel layer, and WebSocket routing ready for consumer implementation.
</objective>

<execution_context>
@/home/chenjiaxing/.claude/get-shit-done/workflows/execute-plan.md
@/home/chenjiaxing/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-Real-time-Notifications/08-CONTEXT.md
@backend/requirements.txt
@backend/config/settings.py
@backend/workorder/services/realtime_notification.py
@backend/workorder/routing.py
@frontend/package.json
</context>

<tasks>

<task type="auto">
  <name>Install and configure Django Channels dependencies</name>
  <files>backend/requirements.txt</files>
  <action>
    Update backend/requirements.txt to include:
    1. channels>=4.0.0 (core Channels library)
    2. daphne>=4.0.0 (ASGI server)
    3. redis>=5.0.0 (Redis client for channel layer)

    Note: channels and daphne are already in requirements.txt but need to verify versions.
    Add redis package for production channel layer support.

    IMPORTANT: Do NOT install packages via Bash. Only update the requirements.txt file.
  </action>
  <verify>grep -E "channels>=|daphne>=|redis>=" backend/requirements.txt</verify>
  <done>requirements.txt contains channels>=4.0.0, daphne>=4.0.0, redis>=5.0.0</done>
</task>

<task type="auto">
  <name>Configure Channels in Django settings</name>
  <files>backend/config/settings.py</files>
  <action>
    Add to backend/config/settings.py:

    1. Add 'channels' to INSTALLED_APPS (after 'corsheaders', before 'workorder')
    2. Add ASGI_APPLICATION setting pointing to 'config.asgi.application'
    3. Add CHANNEL_LAYERS configuration with environment-based backend:
       - Production: Redis backend (when REDIS_URL is set)
       - Development: In-memory backend

    Configuration pattern:
    ```python
    # Channels settings
    ASGI_APPLICATION = 'config.asgi.application'

    CHANNEL_LAYERS = {
        'default': {
            'BACKEND': 'channels_redis.core.RedisChannelLayer',
            'CONFIG': {
                "hosts": [REDIS_URL] if REDIS_URL else [("127.0.0.1", 6379)],
                "symmetric_encryption_keys": [SECRET_KEY],
            },
        },
    }
    ```

    For development without Redis, fall back to:
    ```python
    CHANNEL_LAYERS = {
        'default': {
            'BACKEND': 'channels.layers.InMemoryChannelLayer',
        },
    }
    ```
  </action>
  <verify>grep -E "channels.*INSTALLED_APPS|ASGI_APPLICATION|CHANNEL_LAYERS" backend/config/settings.py</verify>
  <done>settings.py includes channels in INSTALLED_APPS, has ASGI_APPLICATION configured, and has CHANNEL_LAYERS with Redis fallback to InMemoryChannelLayer</done>
</task>

<task type="auto">
  <name>Create ASGI application entry point</name>
  <files>backend/config/asgi.py</files>
  <action>
    Create backend/config/asgi.py with the following structure:

    1. Import necessary modules (os, django, channels)
    2. Setup Django settings module
    3. Get default ASGI application
    4. Create ProtocolTypeRouter that routes:
       - http -> Django's default ASGI handler
       - websocket -> AuthMiddlewareStack -> URLRouter with WebSocket patterns

    The file should look like:
    ```python
    import os
    from django.core.asgi import get_asgi_application
    from channels.routing import ProtocolTypeRouter, URLRouter
    from channels.auth import AuthMiddlewareStack
    from channels.security.websocket import AllowedHostsOriginValidator
    from workorder.routing import websocket_urlpatterns

    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

    application = ProtocolTypeRouter({
        "http": get_asgi_application(),
        "websocket": AllowedHostsOriginValidator(
            AuthMiddlewareStack(
                URLRouter(websocket_urlpatterns)
            )
        ),
    })
    ```

    Key points:
    - AuthMiddlewareStack provides access to request.user in consumers via scope["user"]
    - AllowedHostsOriginValidator validates WebSocket origin against ALLOWED_HOSTS
    - URLRouter imports from workorder.routing.websocket_urlpatterns
  </action>
  <verify>test -f backend/config/asgi.py && grep -q "ProtocolTypeRouter\|AuthMiddlewareStack\|URLRouter" backend/config/asgi.py</verify>
  <done>asgi.py exists with ProtocolTypeRouter routing http and websocket protocols, using AuthMiddlewareStack for authentication</done>
</task>

<task type="auto">
  <name>Verify and update WebSocket routing</name>
  <files>backend/workorder/routing.py</files>
  <action>
    Ensure backend/workorder/routing.py has correct WebSocket routing:

    1. Import necessary: re_path from django.urls, NotificationConsumer
    2. Define websocket_urlpatterns list with notification endpoint

    Expected pattern:
    ```python
    from django.urls import re_path
    from .services.realtime_notification import NotificationConsumer

    websocket_urlpatterns = [
        re_path(r'ws/notifications/$', NotificationConsumer.as_asgi()),
    ]
    ```

    The NotificationConsumer is already defined in services/realtime_notification.py,
    so we just need to ensure it's imported correctly in routing.py.

    Note: The existing routing.py imports from views.notification, but NotificationConsumer
    is in services.realtime_notification. Fix the import if needed.
  </action>
  <verify>grep -q "NotificationConsumer\|websocket_urlpatterns" backend/workorder/routing.py</verify>
  <done>routing.py has websocket_urlpatterns with ws/notifications/ route pointing to NotificationConsumer from services.realtime_notification</done>
</task>

<task type="auto">
  <name>Update WSGI application for compatibility</name>
  <files>backend/config/wsgi.py</files>
  <action>
    Review backend/config/wsgi.py to ensure it's still valid for development server.
    The WSGI application should continue to work for Django's runserver command
    in development (Channels automatically uses WSGI for HTTP requests).

    If wsgi.py doesn't exist, create it:
    ```python
    import os
    from django.core.wsgi import get_wsgi_application

    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    application = get_wsgi_application()
    ```

    This file is standard Django and should already exist. Just verify it exists
    and has correct content.
  </action>
  <verify>test -f backend/config/wsgi.py</verify>
  <done>wsgi.py exists and is configured correctly</done>
</task>

</tasks>

<verification>
After completing all tasks, verify the Channels setup:

1. Run `python manage.py check` to ensure no configuration errors
2. Verify INSTALLED_APPS contains 'channels'
3. Verify ASGI_APPLICATION is set to 'config.asgi.application'
4. Verify CHANNEL_LAYERS configuration exists
5. Verify asgi.py exists with ProtocolTypeRouter
6. Verify routing.py has websocket_urlpatterns

The server should be able to start with `daphne config.asgi:application` or
`python manage.py runserver` (which uses Channels dev server when installed).
</verification>

<success_criteria>
1. Django Channels is properly installed and configured
2. ASGI application entry point exists and is correctly configured
3. Channel layer is configured with Redis for production and in-memory for development
4. WebSocket routing is registered and points to NotificationConsumer
5. Django management commands work without errors
6. The foundation is ready for implementing notification broadcasting
</success_criteria>

<output>
After completion, create `.planning/phases/08-Real-time-Notifications/08-01-SUMMARY.md` with:
- Channels configuration details
- Channel layer backend choice (Redis vs in-memory)
- Any environment variables needed (REDIS_URL)
- Next steps for consumer implementation
</output>
