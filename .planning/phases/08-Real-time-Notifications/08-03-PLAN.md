---
phase: 08-Real-time-Notifications
plan: 03
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - frontend/package.json
  - frontend/src/api/modules/notification.js
  - frontend/src/components/NotificationCenter.vue
  - frontend/src/composables/useWebSocket.js
  - frontend/src/store/modules/notification.js
  - frontend/src/views/Layout.vue
autonomous: true

must_haves:
  truths:
    - "Bell icon appears in header showing unread count badge"
    - "WebSocket connects on user login and authenticates via token"
    - "Notifications arrive in real-time without page refresh"
    - "BroadcastChannel syncs unread count across browser tabs"
    - "Clicking notification expands details before navigation"
    - "Connection state indicator shows online/offline status"
    - "Notifications persist in store and are saved to localStorage"
  artifacts:
    - path: "frontend/src/composables/useWebSocket.js"
      provides: "WebSocket connection management composable"
      contains: "useWebSocket", "connect", "disconnect", "reconnect"
    - path: "frontend/src/components/NotificationCenter.vue"
      provides: "Notification bell icon and dropdown panel"
      contains: "notification-list", "unread-count", "mark-read"
    - path: "frontend/src/api/modules/notification.js"
      provides: "Notification API client"
      contains: "getList", "markAsRead", "markAllAsRead", "getUnreadCount"
    - path: "frontend/src/store/modules/notification.js"
      provides: "Vuex store for notifications"
      contains: "state: { notifications, unreadCount }", "mutations", "actions"
    - path: "frontend/src/views/Layout.vue"
      provides: "App shell with NotificationCenter in header"
      contains: "NotificationCenter"
  key_links:
    - from: "frontend/src/views/Layout.vue"
      to: "frontend/src/composables/useWebSocket.js"
      via: "useWebSocket composable in mounted hook"
      pattern: "useWebSocket.*onMounted"
    - from: "frontend/src/composables/useWebSocket.js"
      to: "ws://localhost:8000/ws/notifications/"
      via: "WebSocket connection"
      pattern: "new WebSocket.*ws://"
    - from: "useWebSocket.onmessage"
      to: "frontend/src/store/modules/notification.js"
      via: "store dispatch"
      pattern: "store\\.dispatch.*notification/"
    - from: "BroadcastChannel"
      to: "other browser tabs"
      via: "cross-tab communication"
      pattern: "broadcastChannel\\.postMessage"
---

<objective>
Create frontend notification component with WebSocket integration for real-time task event delivery.

Purpose: Deliver the user-facing notification experience with in-app bell icon, real-time updates via WebSocket, cross-tab synchronization, and notification history management.

Output: Complete notification UI component with WebSocket connection management, Vuex store integration, and responsive dropdown interface.
</objective>

<execution_context>
@/home/chenjiaxing/.claude/get-shit-done/workflows/execute-plan.md
@/home/chenjiaxing/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-Real-time-Notifications/08-CONTEXT.md
@.planning/phases/08-Real-time-Notifications/08-01-PLAN.md
@.planning/phases/08-Real-time-Notifications/08-02-PLAN.md
@frontend/package.json
@frontend/src/views/Layout.vue
@frontend/src/api/base/BaseAPI.js
@frontend/src/store/index.js
</context>

<tasks>

<task type="auto">
  <name>Create notification API module</name>
  <files>frontend/src/api/modules/notification.js</files>
  <action>
    Create frontend/src/api/modules/notification.js following the BaseAPI pattern:

    The notification API module should:
    1. Extend BaseAPI with base endpoint '/api/notifications/'
    2. Provide standard CRUD methods (inherited from BaseAPI)
    3. Add custom methods: markAsRead, markAllAsRead, getUnreadCount

    Implementation:
    ```javascript
    import request from '@/api/index'
    import { BaseAPI } from '@/api/base/BaseAPI'

    class NotificationAPI extends BaseAPI {
      constructor() {
        super('/api/notifications/', request)
      }

      // 标记单个通知为已读
      markAsRead(id) {
        return this.request({
          url: `${this.baseURL}${id}/mark_read/`,
          method: 'post'
        })
      }

      // 标记所有通知为已读
      markAllAsRead() {
        return this.request({
          url: `${this.baseURL}mark_all_read/`,
          method: 'post'
        })
      }

      // 获取未读数量
      getUnreadCount() {
        return this.request({
          url: `${this.baseURL}unread_count/`,
          method: 'get'
        })
      }

      // 获取通知统计
      getStatistics() {
        return this.request({
          url: `${this.baseURL}statistics/`,
          method: 'get'
        })
      }

      // 删除通知
      delete(id) {
        return this.request({
          url: `${this.baseURL}${id}/delete/`,
          method: 'delete'
        })
      }

      // 删除所有已读
      deleteAllRead() {
        return this.request({
          url: `${this.baseURL}delete_all_read/`,
          method: 'delete'
        })
      }
    }

    export const notificationAPI = new NotificationAPI()
    ```

    Also add to frontend/src/api/modules/index.js:
    ```javascript
    export { notificationAPI } from './notification'
    ```
  </action>
  <verify>grep -q "notificationAPI\|markAsRead\|getUnreadCount" frontend/src/api/modules/notification.js</verify>
  <done>notificationAPI module created with BaseAPI extension and custom notification methods</done>
</task>

<task type="auto">
  <name>Create WebSocket composable with reconnection and BroadcastChannel</name>
  <files>frontend/src/composables/useWebSocket.js</files>
  <action>
    Create frontend/src/composables/useWebSocket.js:

    This composable manages WebSocket connection with:
    1. Token-based authentication via query string
    2. Exponential backoff reconnection (1s, 2s, 4s, 8s, ...)
    3. BroadcastChannel for cross-tab sync
    4. Connection state tracking (connecting, connected, disconnected, error)
    5. Heartbeat/ping handling
    6. Auto-connect on mount and cleanup on unmount

    Implementation:
    ```javascript
    import { ref, onMounted, onUnmounted, computed } from 'vue'
    import { useStore } from 'vuex'

    const BROADCAST_CHANNEL_NAME = 'notification-sync'

    export function useWebSocket() {
      const store = useStore()
      const socket = ref(null)
      const connectionState = ref('disconnected') // connecting, connected, disconnected, error
      const reconnectAttempts = ref(0)
      const reconnectTimeout = ref(null)
      const heartbeatInterval = ref(null)
      const broadcastChannel = ref(null)

      // 构建WebSocket URL
      const buildWebSocketUrl = () => {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
        const host = process.env.VUE_APP_WS_HOST || window.location.host
        const token = store.getters['user/token']
        return `${protocol}//${host}/ws/notifications/?token=${token}`
      }

      // 连接WebSocket
      const connect = () => {
        if (socket.value?.readyState === WebSocket.OPEN) {
          return
        }

        connectionState.value = 'connecting'

        try {
          socket.value = new WebSocket(buildWebSocketUrl())

          socket.value.onopen = () => {
            console.log('[WebSocket] Connected')
            connectionState.value = 'connected'
            reconnectAttempts.value = 0
            startHeartbeat()
          }

          socket.value.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data)
              handleMessage(data)
            } catch (e) {
              console.error('[WebSocket] Failed to parse message:', e)
            }
          }

          socket.value.onclose = (event) => {
            console.log('[WebSocket] Disconnected:', event.code)
            connectionState.value = 'disconnected'
            stopHeartbeat()
            scheduleReconnect()
          }

          socket.value.onerror = (error) => {
            console.error('[WebSocket] Error:', error)
            connectionState.value = 'error'
          }
        } catch (error) {
          console.error('[WebSocket] Connection failed:', error)
          connectionState.value = 'error'
          scheduleReconnect()
        }
      }

      // 处理接收到的消息
      const handleMessage = (data) => {
        switch (data.type) {
          case 'connection_established':
            console.log('[WebSocket] Connection established for user:', data.user_id)
            break
          case 'notification':
            // 保存通知到store
            if (data.data) {
              store.dispatch('notification/addNotification', data.data)
              // 跨标签页同步
              broadcastChannel.value?.postMessage({
                type: 'new_notification',
                data: data.data
              })
            }
            break
          case 'heartbeat':
            // 心跳响应，无需处理
            break
        }
      }

      // 安排重连（指数退避）
      const scheduleReconnect = () => {
        if (reconnectTimeout.value) {
          clearTimeout(reconnectTimeout.value)
        }

        // 指数退避：1s, 2s, 4s, 8s, ... 最大60s
        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts.value), 60000)
        reconnectAttempts.value++

        console.log(`[WebSocket] Reconnecting in ${delay}ms (attempt ${reconnectAttempts.value})`)

        reconnectTimeout.value = setTimeout(() => {
          connect()
        }, delay)
      }

      // 开始心跳
      const startHeartbeat = () => {
        stopHeartbeat()
        heartbeatInterval.value = setInterval(() => {
          if (socket.value?.readyState === WebSocket.OPEN) {
            socket.value.send(JSON.stringify({ type: 'ping' }))
          }
        }, 30000) // 30秒一次心跳
      }

      // 停止心跳
      const stopHeartbeat = () => {
        if (heartbeatInterval.value) {
          clearInterval(heartbeatInterval.value)
          heartbeatInterval.value = null
        }
      }

      // 断开连接
      const disconnect = () => {
        if (reconnectTimeout.value) {
          clearTimeout(reconnectTimeout.value)
          reconnectTimeout.value = null
        }
        stopHeartbeat()
        if (socket.value) {
          socket.value.close()
          socket.value = null
        }
        connectionState.value = 'disconnected'
      }

      // 监听其他标签页的消息
      const setupBroadcastChannel = () => {
        broadcastChannel.value = new BroadcastChannel(BROADCAST_CHANNEL_NAME)
        broadcastChannel.value.onmessage = (event) => {
          if (event.data.type === 'new_notification') {
            store.dispatch('notification/addNotification', event.data.data)
          } else if (event.data.type === 'mark_read') {
            store.dispatch('notification/decrementUnreadCount')
          }
        }
      }

      // 清理BroadcastChannel
      const cleanupBroadcastChannel = () => {
        if (broadcastChannel.value) {
          broadcastChannel.value.close()
          broadcastChannel.value = null
        }
      }

      // 连接状态计算属性
      const isConnected = computed(() => connectionState.value === 'connected')
      const isConnecting = computed(() => connectionState.value === 'connecting')
      const hasError = computed(() => connectionState.value === 'error')

      onMounted(() => {
        setupBroadcastChannel()
        // 只有登录后才连接
        if (store.getters['user/isAuthenticated']) {
          connect()
        }
      })

      onUnmounted(() => {
        disconnect()
        cleanupBroadcastChannel()
      })

      return {
        connectionState: connectionState.value,
        isConnected,
        isConnecting,
        hasError,
        connect,
        disconnect,
        reconnectAttempts
      }
    }
    ```

    Key features per context decisions:
    - Exponential backoff reconnection
    - BroadcastChannel for multi-tab sync
    - Only connects when user is authenticated
  </action>
  <verify>grep -E "useWebSocket|BroadcastChannel|exponential backover|reconnect" frontend/src/composables/useWebSocket.js</verify>
  <done>useWebSocket composable manages connection with exponential backoff, BroadcastChannel sync, and heartbeat</done>
</task>

<task type="auto">
  <name>Create notification Vuex store module</name>
  <files>frontend/src/store/modules/notification.js</files>
  <action>
    Create frontend/src/store/modules/notification.js:

    The notification store should:
    1. Maintain list of notifications and unread count
    2. Persist to localStorage for recovery after page reload
    3. Provide actions for API calls and mutations for state updates
    4. Handle incoming WebSocket notifications

    Implementation:
    ```javascript
    import { notificationAPI } from '@/api/modules'

    const STATE_KEY = 'notification_state'

    // 从localStorage恢复状态
    const loadState = () => {
      try {
        const saved = localStorage.getItem(STATE_KEY)
        if (saved) {
          const parsed = JSON.parse(saved)
          // 只恢复未读计数，不恢复通知列表（避免过期数据）
          return {
            unreadCount: parsed.unreadCount || 0
          }
        }
      } catch (e) {
        console.error('Failed to load notification state:', e)
      }
      return {}
    }

    // 保存状态到localStorage
    const saveState = (state) => {
      try {
        localStorage.setItem(STATE_KEY, JSON.stringify({
          unreadCount: state.unreadCount
        }))
      } catch (e) {
        console.error('Failed to save notification state:', e)
      }
    }

    export default {
      namespaced: true,

      state: () => ({
        notifications: [],
        unreadCount: 0,
        loading: false,
        error: null,
        ...loadState()
      }),

      getters: {
        unreadNotifications: (state) => {
          return state.notifications.filter(n => !n.is_read)
        },
        hasUnread: (state) => state.unreadCount > 0,
        unreadCountDisplay: (state) => {
          return state.unreadCount > 99 ? '99+' : state.unreadCount
        }
      },

      mutations: {
        SET_NOTIFICATIONS(state, notifications) {
          state.notifications = notifications
        },
        ADD_NOTIFICATION(state, notification) {
          // 添加到列表开头
          state.notifications.unshift({
            ...notification,
            is_read: false
          })
          // 增加未读计数
          if (!notification.is_read) {
            state.unreadCount++
            saveState(state)
          }
        },
        MARK_AS_READ(state, notificationId) {
          const notification = state.notifications.find(n => n.id === notificationId)
          if (notification && !notification.is_read) {
            notification.is_read = true
            state.unreadCount = Math.max(0, state.unreadCount - 1)
            saveState(state)
          }
        },
        MARK_ALL_AS_READ(state) {
          state.notifications.forEach(n => n.is_read = true)
          state.unreadCount = 0
          saveState(state)
        },
        REMOVE_NOTIFICATION(state, notificationId) {
          const index = state.notifications.findIndex(n => n.id === notificationId)
          if (index > -1) {
            const notification = state.notifications[index]
            state.notifications.splice(index, 1)
            if (!notification.is_read) {
              state.unreadCount = Math.max(0, state.unreadCount - 1)
              saveState(state)
            }
          }
        },
        SET_UNREAD_COUNT(state, count) {
          state.unreadCount = count
          saveState(state)
        },
        DECREMENT_UNREAD_COUNT(state) {
          state.unreadCount = Math.max(0, state.unreadCount - 1)
          saveState(state)
        },
        SET_LOADING(state, loading) {
          state.loading = loading
        },
        SET_ERROR(state, error) {
          state.error = error
        }
      },

      actions: {
        async fetchNotifications({ commit }, params = {}) {
          commit('SET_LOADING', true)
          try {
            const response = await notificationAPI.getList(params)
            commit('SET_NOTIFICATIONS', response.data.results || response.data)
            return response.data
          } catch (error) {
            commit('SET_ERROR', error.message)
            throw error
          } finally {
            commit('SET_LOADING', false)
          }
        },

        async fetchUnreadCount({ commit }) {
          try {
            const response = await notificationAPI.getUnreadCount()
            commit('SET_UNREAD_COUNT', response.data.unread_count)
            return response.data.unread_count
          } catch (error) {
            console.error('Failed to fetch unread count:', error)
          }
        },

        async markAsRead({ commit }, notificationId) {
          try {
            await notificationAPI.markAsRead(notificationId)
            commit('MARK_AS_READ', notificationId)
            // 通知其他标签页
            const bc = new BroadcastChannel('notification-sync')
            bc.postMessage({ type: 'mark_read' })
            bc.close()
          } catch (error) {
            console.error('Failed to mark as read:', error)
            throw error
          }
        },

        async markAllAsRead({ commit }) {
          try {
            await notificationAPI.markAllAsRead()
            commit('MARK_ALL_AS_READ')
          } catch (error) {
            console.error('Failed to mark all as read:', error)
            throw error
          }
        },

        async deleteNotification({ commit }, notificationId) {
          try {
            await notificationAPI.delete(notificationId)
            commit('REMOVE_NOTIFICATION', notificationId)
          } catch (error) {
            console.error('Failed to delete notification:', error)
            throw error
          }
        },

        // 添加来自WebSocket的通知
        addNotification({ commit }, notification) {
          commit('ADD_NOTIFICATION', notification)
          // 播放提示音（如果启用）
          if (localStorage.getItem('notification_sound_enabled') === 'true') {
            playNotificationSound()
          }
        }
      }
    }

    // 播放提示音
    function playNotificationSound() {
      const audio = new Audio('/static/sounds/notification.mp3')
      audio.volume = 0.3
      audio.play().catch(() => {
        // 忽略自动播放限制错误
      })
    }
    ```

    Add to frontend/src/store/index.js:
    ```javascript
    import notification from './modules/notification'

    export default new Vuex.Store({
      modules: {
        // ... existing modules
        notification,
      }
    })
    ```
  </action>
  <verify>grep -E "ADD_NOTIFICATION|MARK_AS_READ|SET_UNREAD_COUNT|unreadCount" frontend/src/store/modules/notification.js</verify>
  <done>Notification store module manages notifications, unread count, and persists to localStorage</done>
</task>

<task type="auto">
  <name>Create NotificationCenter component with bell icon and dropdown</name>
  <files>frontend/src/components/NotificationCenter.vue</files>
  <action>
    Create frontend/src/components/NotificationCenter.vue:

    Per context decisions:
    - Only in-app notifications (bell icon + dropdown)
    - Only update count, no auto toast
    - Two-stage display: compact list, click to expand details
    - Click to view details, then decide whether to navigate

    Implementation:
    ```vue
    <template>
      <div class="notification-center">
        <!-- 铃铛图标 -->
        <el-badge
          :value="unreadCountDisplay"
          :hidden="!hasUnread"
          class="notification-badge"
        >
          <el-button
            class="notification-bell"
            :class="{ 'has-error': connectionError }"
            circle
            icon="el-icon-bell"
            @click="toggleDropdown"
          >
            <i v-if="connectionError" class="el-icon-warning connection-error-icon" />
          </el-button>
        </el-badge>

        <!-- 下拉面板 -->
        <el-popover
          ref="popover"
          v-model="dropdownVisible"
          placement="bottom-end"
          width="380"
          trigger="manual"
          popper-class="notification-popover"
        >
          <div class="notification-panel" v-loading="loading">
            <!-- 头部 -->
            <div class="notification-header">
              <span class="notification-title">通知</span>
              <div class="notification-actions">
                <el-button
                  v-if="hasUnread"
                  type="text"
                  size="mini"
                  @click="markAllAsRead"
                >
                  全部已读
                </el-button>
                <el-button
                  type="text"
                  size="mini"
                  @click="goToNotificationPage"
                >
                  查看全部
                </el-button>
              </div>
            </div>

            <!-- 连接状态指示器 -->
            <div
              v-if="connectionStatus !== 'connected'"
              class="connection-status"
              :class="connectionStatus"
            >
              <i :class="connectionStatusIcon" />
              <span>{{ connectionStatusText }}</span>
            </div>

            <!-- 通知列表 -->
            <div class="notification-list">
              <template v-if="notifications.length > 0">
                <div
                  v-for="notification in displayedNotifications"
                  :key="notification.id"
                  class="notification-item"
                  :class="{ 'is-unread': !notification.is_read, 'is-expanded': expandedId === notification.id }"
                  @click="handleNotificationClick(notification)"
                >
                  <!-- 紧凑视图 -->
                  <div class="notification-compact">
                    <div class="notification-icon">
                      <i :class="getNotificationIcon(notification)" />
                    </div>
                    <div class="notification-content">
                      <div class="notification-title-text">
                        {{ notification.data?.title || notification.title }}
                      </div>
                      <div class="notification-time">
                        {{ formatTime(notification.created_at || notification.timestamp) }}
                      </div>
                    </div>
                    <div v-if="!notification.is_read" class="unread-dot" />
                  </div>

                  <!-- 展开详情 -->
                  <div v-if="expandedId === notification.id" class="notification-details">
                    <p class="notification-message">
                      {{ notification.data?.message || notification.message }}
                    </p>
                    <div v-if="notification.data" class="notification-meta">
                      <span v-if="notification.data.workorder_number" class="meta-item">
                        <i class="el-icon-document" />
                        {{ notification.data.workorder_number }}
                      </span>
                      <span v-if="notification.data.process_name" class="meta-item">
                        <i class="el-icon-s-operation" />
                        {{ notification.data.process_name }}
                      </span>
                    </div>
                    <div class="notification-actions-row">
                      <el-button
                        v-if="canNavigate(notification)"
                        type="primary"
                        size="mini"
                        @click.stop="navigateToTask(notification)"
                      >
                        查看任务
                      </el-button>
                      <el-button
                        type="text"
                        size="mini"
                        @click.stop="markAsRead(notification.id)"
                      >
                        标记已读
                      </el-button>
                      <el-button
                        type="text"
                        size="mini"
                        @click.stop="deleteNotification(notification.id)"
                      >
                        删除
                      </el-button>
                    </div>
                  </div>
                </div>
              </template>
              <el-empty v-else description="暂无通知" :image-size="80" />
            </div>
          </div>

          <div slot="reference" class="notification-reference"></div>
        </el-popover>

        <!-- 声音设置开关 -->
        <el-tooltip content="通知声音" placement="bottom">
          <el-switch
            v-model="soundEnabled"
            class="sound-toggle"
            active-text=""
            inactive-text=""
            @change="onSoundToggle"
          />
        </el-tooltip>
      </div>
    </template>

    <script>
    import { computed, ref, onMounted, onUnmounted, watch } from 'vue'
    import { useStore } from 'vuex'
    import { useRouter } from 'vue-router'
    import { useWebSocket } from '@/composables/useWebSocket'

    export default {
      name: 'NotificationCenter',

      setup() {
        const store = useStore()
        const router = useRouter()
        const popover = ref(null)
        const dropdownVisible = ref(false)
        const expandedId = ref(null)

        // WebSocket连接状态
        const { isConnected, isConnecting, hasError, connectionState } = useWebSocket()

        // 声音设置
        const soundEnabled = ref(localStorage.getItem('notification_sound_enabled') === 'true')

        // 计算属性
        const notifications = computed(() => store.state.notification.notifications)
        const unreadCount = computed(() => store.state.notification.unreadCount)
        const hasUnread = computed(() => unreadCount.value > 0)
        const unreadCountDisplay = computed(() => unreadCount.value > 99 ? '99+' : unreadCount.value)
        const loading = computed(() => store.state.notification.loading)

        const connectionStatus = computed(() => {
          if (hasError.value) return 'error'
          if (isConnecting.value) return 'connecting'
          if (isConnected.value) return 'connected'
          return 'disconnected'
        })

        const connectionError = computed(() => hasError.value)

        const displayedNotifications = computed(() => {
          return notifications.value.slice(0, 10) // 最多显示10条
        })

        // 方法
        const toggleDropdown = () => {
          dropdownVisible.value = !dropdownVisible.value
          if (dropdownVisible.value && notifications.value.length === 0) {
            loadNotifications()
          }
        }

        const loadNotifications = async () => {
          try {
            await store.dispatch('notification/fetchNotifications', { page_size: 20 })
          } catch (e) {
            console.error('Failed to load notifications:', e)
          }
        }

        const handleNotificationClick = (notification) => {
          if (expandedId.value === notification.id) {
            expandedId.value = null
          } else {
            expandedId.value = notification.id
            if (!notification.is_read) {
              markAsRead(notification.id)
            }
          }
        }

        const markAsRead = async (id) => {
          try {
            await store.dispatch('notification/markAsRead', id)
          } catch (e) {
            console.error('Failed to mark as read:', e)
          }
        }

        const markAllAsRead = async () => {
          try {
            await store.dispatch('notification/markAllAsRead')
          } catch (e) {
            console.error('Failed to mark all as read:', e)
          }
        }

        const deleteNotification = async (id) => {
          try {
            await store.dispatch('notification/deleteNotification', id)
          } catch (e) {
            console.error('Failed to delete notification:', e)
          }
        }

        const canNavigate = (notification) => {
          return notification.data?.task_id || notification.task_id
        }

        const navigateToTask = (notification) => {
          const taskId = notification.data?.task_id || notification.task_id
          if (taskId) {
            dropdownVisible.value = false
            router.push({ name: 'TaskDetail', params: { id: taskId } })
          }
        }

        const goToNotificationPage = () => {
          dropdownVisible.value = false
          router.push({ name: 'Notifications' })
        }

        const formatTime = (timeStr) => {
          if (!timeStr) return ''
          const date = new Date(timeStr)
          const now = new Date()
          const diff = now - date

          if (diff < 60000) return '刚刚'
          if (diff < 3600000) return `${Math.floor(diff / 60000)}分钟前`
          if (diff < 86400000) return `${Math.floor(diff / 3600000)}小时前`
          if (diff < 604800000) return `${Math.floor(diff / 86400000)}天前`

          return date.toLocaleDateString()
        }

        const getNotificationIcon = (notification) => {
          const type = notification.event_type || notification.notification_type
          const iconMap = {
            'task_assigned': 'el-icon-user-solid',
            'task_completed': 'el-icon-circle-check',
            'task_started': 'el-icon-video-play',
            'workorder_created': 'el-icon-document',
            'workorder_approved': 'el-icon-success',
            'workorder_rejected': 'el-icon-error',
            'deadline_warning': 'el-icon-warning',
            'system_announcement': 'el-icon-bell'
          }
          return iconMap[type] || 'el-icon-bell'
        }

        const onSoundToggle = (value) => {
          localStorage.setItem('notification_sound_enabled', value.toString())
        }

        // 定时刷新未读计数
        let refreshInterval = null
        onMounted(() => {
          loadNotifications()
          store.dispatch('notification/fetchUnreadCount')
          refreshInterval = setInterval(() => {
            store.dispatch('notification/fetchUnreadCount')
          }, 60000) // 每分钟刷新一次
        })

        onUnmounted(() => {
          if (refreshInterval) {
            clearInterval(refreshInterval)
          }
        })

        // 监听新通知，自动展开下拉（可选，根据上下文决定不自动弹出）
        watch(unreadCount, (newVal, oldVal) => {
          if (newVal > oldVal) {
            // 有新通知，仅更新计数，不自动弹出（符合上下文决策）
          }
        })

        return {
          popover,
          dropdownVisible,
          expandedId,
          notifications,
          displayedNotifications,
          hasUnread,
          unreadCountDisplay,
          loading,
          connectionStatus,
          connectionError,
          connectionState,
          soundEnabled,
          toggleDropdown,
          handleNotificationClick,
          markAsRead,
          markAllAsRead,
          deleteNotification,
          canNavigate,
          navigateToTask,
          goToNotificationPage,
          formatTime,
          getNotificationIcon,
          onSoundToggle
        }
      },

      computed: {
        connectionStatusIcon() {
          const icons = {
            connecting: 'el-icon-loading',
            connected: 'el-icon-circle-check',
            disconnected: 'el-icon-warning',
            error: 'el-icon-circle-close'
          }
          return icons[this.connectionStatus] || 'el-icon-warning'
        },

        connectionStatusText() {
          const texts = {
            connecting: '连接中...',
            connected: '已连接',
            disconnected: '连接已断开',
            error: '连接错误'
          }
          return texts[this.connectionStatus] || '未知状态'
        }
      }
    }
    </script>

    <style scoped>
    .notification-center {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .notification-badge {
      margin-right: 0;
    }

    .notification-bell {
      border: none;
      background: transparent;
      font-size: 20px;
      padding: 8px;
    }

    .notification-bell:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .notification-bell.has-error {
      color: #F56C6C;
    }

    .connection-error-icon {
      position: absolute;
      bottom: 0;
      right: 0;
      font-size: 10px;
    }

    .sound-toggle {
      --el-switch-off-color: #dcdfe6;
      --el-switch-on-color: #409EFF;
    }

    .notification-reference {
      display: none;
    }
    </style>
    ```

    Key features per context decisions:
    - Bell icon with unread count badge (99+ for overflow)
    - Two-stage display: click to expand details
    - Connection state indicator
    - Sound toggle (default off)
    - No auto-popup, only count updates
  </action>
  <verify>grep -E "NotificationCenter\|el-badge\|el-popover\|notification-panel" frontend/src/components/NotificationCenter.vue</verify>
  <done>NotificationCenter component has bell icon, dropdown panel, two-stage display, and connection indicator</done>
</task>

<task type="auto">
  <name>Integrate NotificationCenter into Layout header</name>
  <files>frontend/src/views/Layout.vue</files>
  <action>
    Update frontend/src/views/Layout.vue to add NotificationCenter:

    1. Import NotificationCenter component
    2. Add it to header-right section, before user dropdown
    3. Initialize WebSocket connection in onMounted

    Changes to Layout.vue:

    ```vue
    <template>
      <!-- ... existing template ... -->
      <el-header class="header">
        <!-- ... existing header-left ... -->
        <div class="header-right">
          <!-- Add NotificationCenter here -->
          <notification-center />

          <el-dropdown @command="handleCommand">
            <!-- existing user dropdown -->
          </el-dropdown>
        </div>
      </el-header>
      <!-- ... rest of template ... -->
    </template>

    <script>
    import { authAPI } from '@/api/modules'
    import NotificationCenter from '@/components/NotificationCenter.vue'
    import { onMounted } from 'vue'

    export default {
      name: 'Layout',
      components: {
        NotificationCenter
      },
      // ... existing options ...
      setup() {
        // ... existing setup code ...

        onMounted(() => {
          // Load notifications on mount
          // This will be handled by NotificationCenter's onMounted
        })

        return {
          // ... existing returns ...
        }
      }
    }
    </script>
    ```

    Update header-right styles to accommodate the notification center:
    ```css
    .header-right {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    ```
  </action>
  <verify>grep -q "NotificationCenter\|notification-center" frontend/src/views/Layout.vue</verify>
  <done>Layout.vue imports and renders NotificationCenter in header-right section</done>
</task>

</tasks>

<verification>
After completing all tasks, verify the notification UI:

1. Open the app and log in
2. Verify bell icon appears in header
3. Check WebSocket connection status (should be "connected")
4. Trigger a task assignment from another browser/device
5. Verify notification arrives without page refresh
6. Verify unread count badge updates
7. Open app in second tab and verify count syncs via BroadcastChannel
8. Click notification to expand details
9. Click "查看任务" to navigate to task detail
10. Toggle sound setting and verify it persists

Test connection states:
- Disconnect network → status shows "连接已断开"
- Reconnect → status shows "连接中..." then "已连接"
</verification>

<success_criteria>
1. Bell icon displays in header with unread count badge
2. WebSocket connects automatically on login
3. Notifications arrive in real-time without refresh
4. Unread count syncs across browser tabs
5. Clicking notification expands details before navigation
6. Connection state indicator shows current status
7. Sound toggle preference persists to localStorage
8. Notifications are persisted in Vuex store and recovered after reload
</success_criteria>

<output>
After completion, create `.planning/phases/08-Real-time-Notifications/08-03-SUMMARY.md` with:
- NotificationCenter component implementation details
- WebSocket connection management approach
- BroadcastChannel sync behavior
- Notification UI/UX decisions
- Any issues with Vue 2.7 Composition API compatibility
- User testing feedback
</output>
