---
phase: 10-production-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/requirements.txt
  - backend/workorder/tests/factories/__init__.py
  - backend/workorder/tests/factories/base.py
  - backend/workorder/tests/factories/users.py
  - backend/workorder/tests/factories/workorder.py
  - backend/workorder/tests/integration/__init__.py
  - backend/workorder/tests/integration/test_task_workflows.py
  - backend/workorder/tests/integration/test_workorder_lifecycle.py
  - backend/workorder/tests/integration/test_notification_workflows.py
  - backend/workorder/tests/integration/test_dispatch_workflows.py
  - backend/workorder/tests/conftest.py
  - backend/.coveragerc
autonomous: true

must_haves:
  truths:
    - "All critical task workflows (creation, approval, dispatch, assignment, completion) have passing integration tests"
    - "Test coverage exceeds 80% for all tested modules"
    - "Integration tests use factory_boy for declarative test data generation"
    - "Tests run in isolation with pytest-django's database isolation"
    - "Concurrent task claiming is properly tested with threading"
    - "Permission boundaries are tested for supervisor, operator, and maker roles"
    - "Error paths (403, 404, 409) are tested alongside happy paths"
  artifacts:
    - path: "backend/requirements.txt"
      provides: "pytest-django and factory_boy dependencies"
      contains: "pytest-django"
    - path: "backend/workorder/tests/factories/__init__.py"
      provides: "Factory Boy exports"
      min_lines: 10
    - path: "backend/workorder/tests/factories/base.py"
      provides: "Department and Process factories"
      contains: "class DepartmentFactory"
    - path: "backend/workorder/tests/factories/users.py"
      provides: "User factory with role-based creation"
      contains: "class UserFactory"
    - path: "backend/workorder/tests/factories/workorder.py"
      provides: "WorkOrder and WorkOrderTask factories"
      contains: "class WorkOrderFactory"
    - path: "backend/workorder/tests/integration/test_task_workflows.py"
      provides: "Task workflow integration tests"
      contains: "test_workorder_approval_converts_draft_tasks"
    - path: "backend/workorder/tests/integration/test_workorder_lifecycle.py"
      provides: "Full work order lifecycle tests"
      contains: "test_full_workorder_lifecycle"
    - path: "backend/workorder/tests/integration/test_notification_workflows.py"
      provides: "Notification workflow tests"
      contains: "test_task_assignment_creates_notification"
    - path: "backend/workorder/tests/integration/test_dispatch_workflows.py"
      provides: "Auto-dispatch integration tests"
      contains: "test_auto_dispatch_on_approval"
    - path: "backend/.coveragerc"
      provides: "Coverage configuration"
      contains: "[run]"
  key_links:
    - from: "backend/workorder/tests/integration/test_*.py"
      to: "backend/workorder/tests/factories/*.py"
      via: "from workorder.tests.factories import"
      pattern: "from workorder\\.tests\\.factories import"
    - from: "pytest command"
      to: "pytest-django test runner"
      via: "pytest --cov=workorder"
      pattern: "pytest.*--cov"
    - from: "integration tests"
      to: "Django REST Framework API views"
      via: "APIClient from rest_framework.test"
      pattern: "from rest_framework\\.test import APIClient"
---

<objective>
Implement comprehensive integration tests for core task workflows using pytest-django and factory_boy. This ensures system reliability by testing end-to-end workflows from API request to database changes with proper test isolation and coverage measurement.

Purpose: Integration testing provides confidence that the system works correctly when components interact. Tests catch regressions before production and serve as living documentation of expected behavior.

Output: A test suite with >80% coverage covering all critical user workflows (task creation, approval, dispatch, assignment, completion), using factory_boy for test data and pytest-django for test execution.
</objective>

<execution_context>
@/home/chenjiaxing/.claude/get-shit-done/workflows/execute-plan.md
@/home/chenjiaxing/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-production-hardening/10-CONTEXT.md
@.planning/phases/10-production-hardening/10-RESEARCH.md
@backend/workorder/models/
@backend/workorder/views/
@backend/workorder/tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Install pytest-django and factory_boy dependencies</name>
  <files>backend/requirements.txt</files>
  <action>
    Update backend/requirements.txt to add the testing dependencies:

    ```
    # Testing (already has coverage, flake8)
    pytest-django==4.8.0
    factory_boy==3.3.0
    pytest-factoryboy==2.7.0
    pytest-xdist==3.5.0  # For parallel test execution
    ```

    Then install the new dependencies:
    ```bash
    cd backend && pip install -r requirements.txt
    ```

    These versions are compatible with Django 4.2 and Python 3.11+. pytest-django provides the django_db decorator and test database isolation, factory_boy provides declarative test data creation, and pytest-xdist enables parallel test execution.
  </action>
  <verify>
    pip list | grep -E "(pytest-django|factory_boy|pytest-xdist)"
  </verify>
  <done>
    pytest-django 4.8.0, factory_boy 3.3.0, and pytest-xdist 3.5.0 are installed
  </done>
</task>

<task type="auto">
  <name>Create pytest configuration and coverage settings</name>
  <files>backend/pytest.ini, backend/.coveragerc</files>
  <action>
    1. Create backend/pytest.ini with pytest-django configuration:
    ```ini
    [pytest]
    DJANGO_SETTINGS_MODULE = config.settings
    python_files = test_*.py
    python_classes = Test*
    python_functions = test_*
    testpaths = workorder/tests
    addopts =
        --verbose
        --tb=short
        --cov=workorder
        --cov-report=term-missing
        --cov-report=html
        --cov-fail-under=80
    markers =
        django_db: Mark test as requiring database access
        integration: Mark test as integration test
        unit: Mark test as unit test
    ```

    2. Create backend/.coveragerc to configure coverage measurement:
    ```ini
    [run]
    source = workorder
    omit =
        */tests/*
        */migrations/*
        */conftest.py
        */__pycache__/*
        */venv/*
        */env/*
    [html]
    directory = htmlcov
    [report]
    exclude_lines =
        pragma: no cover
        def __repr__
        raise AssertionError
        raise NotImplementedError
        if __name__ == .__main__.:
        if TYPE_CHECKING:
    ```

    3. Update backend/workorder/tests/conftest.py to add pytest fixtures:
    ```python
    import pytest
    from django.contrib.auth import get_user_model

    User = get_user_model()

    @pytest.fixture
    def test_password():
        return 'test_pass_123'

    @pytest.fixture
    def auto_login_user(db, client):
        """Fixture that creates a user and logs them in"""
        def make_user(**kwargs):
            user = User.objects.create_user(
                username=kwargs.get('username', 'testuser'),
                password=kwargs.get('password', 'test_pass_123'),
                email=kwargs.get('email', 'test@example.com'),
                is_staff=kwargs.get('is_staff', True),
            )
            client.force_login(user)
            return client, user
        return make_user

    @pytest.fixture
    def api_client():
        """APIClient fixture for DRF API testing"""
        from rest_framework.test import APIClient
        return APIClient()
    ```

    This enables pytest to find and run Django tests with coverage measurement, enforcing >80% coverage.
  </action>
  <verify>
    cd backend && pytest --collect-only 2>&1 | head -20
  </verify>
  <done>
    pytest discovers tests and coverage is configured with 80% minimum threshold
  </done>
</task>

<task type="auto">
  <name>Create factory_boy test data factories</name>
  <files>backend/workorder/tests/factories/__init__.py, backend/workorder/tests/factories/base.py, backend/workorder/tests/factories/users.py, backend/workorder/tests/factories/workorder.py</files>
  <action>
    Create declarative test data factories using factory_boy. Create the factory module structure:

    1. Create backend/workorder/tests/factories/__init__.py:
    ```python
    """Test data factories for workorder app"""
    from .base import DepartmentFactory, ProcessFactory
    from .users import UserFactory
    from .workorder import (
        CustomerFactory, WorkOrderFactory, WorkOrderProcessFactory,
        WorkOrderTaskFactory, WorkOrderProductFactory
    )

    __all__ = [
        'DepartmentFactory', 'ProcessFactory', 'UserFactory',
        'CustomerFactory', 'WorkOrderFactory', 'WorkOrderProcessFactory',
        'WorkOrderTaskFactory', 'WorkOrderProductFactory',
    ]
    ```

    2. Create backend/workorder/tests/factories/base.py:
    ```python
    """Factory Boy definitions for base models"""
    import factory
    from workorder.models.base import Department, Process

    class DepartmentFactory(factory.django.DjangoModelFactory):
        class Meta:
            model = Department
            django_get_or_create = ('code',)

        name = factory.Sequence(lambda n: f"Department {n}")
        code = factory.Sequence(lambda n: f"DEPT{n:03d}")
        is_active = True

    class ProcessFactory(factory.django.DjangoModelFactory):
        class Meta:
            model = Process
            django_get_or_create = ('code',)

        name = factory.Sequence(lambda n: f"Process {n}")
        code = factory.Sequence(lambda n: f"PROC{n:03d}")
        is_builtin = False
        is_parallel = False
    ```

    3. Create backend/workorder/tests/factories/users.py:
    ```python
    """Factory Boy definitions for User model"""
    import factory
    from django.contrib.auth import get_user_model
    from .base import DepartmentFactory

    User = get_user_model()

    class UserFactory(factory.django.DjangoModelFactory):
        class Meta:
            model = User
            django_get_or_create = ('username',)

        username = factory.Sequence(lambda n: f"user_{n}")
        email = factory.LazyAttribute(lambda obj: f"{obj.username}@example.com")
        first_name = factory.Faker('first_name', locale='zh_CN')
        last_name = factory.Faker('last_name', locale='zh_CN')
        is_staff = True
        is_active = True

        # Post-generation: add to department
        @factory.post_generation
        def department(self, create, extracted, **kwargs):
            if not create:
                return
            if extracted:
                from workorder.models import UserProfile
                profile, _ = UserProfile.objects.get_or_create(user=self)
                profile.department = extracted
                profile.save()
            elif kwargs.get('auto_department', True):
                from workorder.models import UserProfile
                dept = DepartmentFactory()
                profile, _ = UserProfile.objects.get_or_create(user=self)
                profile.department = dept
                profile.role = kwargs.get('role', 'operator')
                profile.save()

        @classmethod
        def _create(cls, model_class, *args, **kwargs):
            """Use create_user for password hashing"""
            password = kwargs.pop('password', None)
            user = model_class(**kwargs)
            if password:
                user.set_password(password)
            user.save()
            return user
    ```

    4. Create backend/workorder/tests/factories/workorder.py:
    ```python
    """Factory Boy definitions for work order models"""
    import factory
    from datetime import date, timedelta
    from django.utils import timezone
    from .base import DepartmentFactory, ProcessFactory
    from .users import UserFactory
    from workorder.models.core import (
        WorkOrder, WorkOrderProcess, WorkOrderTask
    )
    from workorder.models.base import Customer
    from workorder.models.products import Product

    class CustomerFactory(factory.django.DjangoModelFactory):
        class Meta:
            model = Customer

        name = factory.Sequence(lambda n: f"Customer {n}")
        contact_person = factory.Faker('name', locale='zh_CN')
        phone = factory.Faker('phone_number', locale='zh_CN')
        email = factory.LazyAttribute(lambda obj: f"contact{obj.id}@example.com" if obj.id else "contact@example.com")

    class ProductFactory(factory.django.DjangoModelFactory):
        class Meta:
            model = Product

        name = factory.Sequence(lambda n: f"Product {n}")
        code = factory.Sequence(lambda n: f"PROD{n:04d}")
        specification = "100x100mm"
        unit = "ä»¶"
        unit_price = 10.00

    class WorkOrderFactory(factory.django.DjangoModelFactory):
        class Meta:
            model = WorkOrder

        order_number = factory.Sequence(lambda n: f"WO{n:06d}")
        customer = factory.SubFactory(CustomerFactory)
        created_by = factory.SubFactory(UserFactory)
        manager = factory.SubFactory(UserFactory)
        production_quantity = 100
        order_date = factory.LazyFunction(lambda: date.today())
        delivery_date = factory.LazyFunction(lambda: date.today() + timedelta(days=7))
        priority = 'normal'
        approval_status = 'draft'

        # Post-generation: create processes
        @factory.post_generation
        def processes(obj, create, extracted, **kwargs):
            if not create:
                return
            if extracted is None:
                # Create default processes
                extracted = [WorkOrderProcessFactory(work_order=obj)]
            elif isinstance(extracted, int):
                # Create N processes
                WorkOrderProcessFactory.create_batch(extracted, work_order=obj)
            else:
                # Use provided list
                for process_data in extracted:
                    WorkOrderProcessFactory(work_order=obj, **process_data)

    class WorkOrderProcessFactory(factory.django.DjangoModelFactory):
        class Meta:
            model = WorkOrderProcess

        work_order = factory.SubFactory(WorkOrderFactory)
        process = factory.SubFactory(ProcessFactory)
        sequence = 10
        status = 'pending'

        # Post-generation: create tasks
        @factory.post_generation
        def tasks(obj, create, extracted, **kwargs):
            if not create:
                return
            if extracted is None:
                # Create one task by default
                extracted = 1
            if isinstance(extracted, int) and extracted > 0:
                WorkOrderTaskFactory.create_batch(
                    extracted,
                    work_order_process=obj,
                    work_order=obj.work_order
                )

    class WorkOrderTaskFactory(factory.django.DjangoModelFactory):
        class Meta:
            model = WorkOrderTask

        work_order = factory.SubFactory(WorkOrderFactory)
        work_order_process = factory.SubFactory(WorkOrderProcessFactory)
        process = factory.LazyAttribute(lambda obj: obj.work_order_process.process)
        status = 'draft'
        priority = 'normal'

        # Conditional assignment
        assigned_department = factory.Maybe(
            'assign_department',
            factory.SubFactory(DepartmentFactory),
            None
        )
        assigned_operator = factory.Maybe(
            'assign_operator',
            factory.SubFactory(UserFactory),
            None
        )

        assign_department = False  # Set True to auto-assign department
        assign_operator = False    # Set True to auto-assign operator
    ```

    Factory Boy provides declarative test data creation with automatic relationship handling and post-generation hooks for complex test scenarios.
  </action>
  <verify>
    cd backend && python -c "from workorder.tests.factories import WorkOrderFactory; w = WorkOrderFactory(); print(f'Created: {w.order_number}')"
  </verify>
  <done>
    Factories create test data with proper relationships and post-generation hooks
  </done>
</task>

<task type="auto">
  <name>Create task workflow integration tests</name>
  <files>backend/workorder/tests/integration/test_task_workflows.py</files>
  <action>
    Create backend/workorder/tests/integration/test_task_workflows.py with comprehensive task workflow tests:

    ```python
    """Integration tests for task workflows"""
    import pytest
    import threading
    from rest_framework import status
    from rest_framework.test import APIClient
    from workorder.tests.factories import (
        WorkOrderFactory, UserFactory, DepartmentFactory, ProcessFactory,
        WorkOrderTaskFactory, WorkOrderProcessFactory
    )
    from workorder.models import WorkOrder, WorkOrderTask

    @pytest.mark.django_db
    @pytest.mark.integration
    class TestWorkOrderTaskWorkflow:
        """Test complete workflow: create workorder -> approve -> tasks generated"""

        def test_workorder_approval_converts_draft_tasks(self, api_client):
            """
            GIVEN: A workorder with draft tasks
            WHEN: Supervisor approves the workorder
            THEN: Draft tasks convert to formal pending status
            """
            # Arrange: Create supervisor and workorder
            dept = DepartmentFactory(name='Printing')
            supervisor = UserFactory(username='supervisor', department=dept)
            workorder = WorkOrderFactory(
                approval_status='submitted',
                created_by=supervisor,
                processes=0  # We'll create processes manually
            )

            # Create process with draft tasks
            process = ProcessFactory(name='Offset Printing')
            wop = WorkOrderProcessFactory(work_order=workorder, process=process, tasks=3)

            # Verify draft tasks exist
            draft_tasks = workorder.tasks.filter(status='draft')
            assert draft_tasks.count() == 3

            # Act: Approve workorder
            api_client.force_authenticate(user=supervisor)
            response = api_client.post(f'/api/workorders/{workorder.id}/approve/')

            # Assert: Tasks are now formal (pending)
            assert response.status_code == status.HTTP_200_OK
            workorder.refresh_from_db()
            assert workorder.approval_status == 'approved'

            tasks = workorder.tasks.all()
            assert tasks.count() == 3
            assert all(task.status == 'pending' for task in tasks)

        def test_workorder_rejection_deletes_draft_tasks(self, api_client):
            """
            GIVEN: A workorder with draft tasks
            WHEN: Supervisor rejects the workorder
            THEN: All draft tasks are deleted
            """
            dept = DepartmentFactory()
            supervisor = UserFactory(username='supervisor', department=dept)
            workorder = WorkOrderFactory(
                approval_status='submitted',
                created_by=supervisor,
                processes=0
            )

            process = ProcessFactory()
            wop = WorkOrderProcessFactory(work_order=workorder, process=process, tasks=3)

            # Verify draft tasks exist
            assert workorder.tasks.filter(status='draft').count() == 3

            # Act: Reject workorder
            api_client.force_authenticate(user=supervisor)
            response = api_client.post(f'/api/workorders/{workorder.id}/reject/')

            # Assert: Tasks are deleted
            assert response.status_code == status.HTTP_200_OK
            workorder.refresh_from_db()
            assert workorder.approval_status == 'rejected'
            assert workorder.tasks.count() == 0

        def test_task_assignment_by_supervisor(self, api_client):
            """
            GIVEN: A pending task and an operator
            WHEN: Supervisor assigns the task
            THEN: Task is assigned to operator and status updated
            """
            dept = DepartmentFactory()
            supervisor = UserFactory(username='supervisor', department=dept, role='supervisor')
            operator = UserFactory(username='operator', department=dept, role='operator')

            task = WorkOrderTaskFactory(
                status='pending',
                assigned_department=dept
            )

            api_client.force_authenticate(user=supervisor)
            response = api_client.post(f'/api/tasks/{task.id}/assign/', {
                'operator_id': operator.id
            }, format='json')

            assert response.status_code == status.HTTP_200_OK
            task.refresh_from_db()
            assert task.assigned_operator == operator

        def test_concurrent_task_claiming(self, api_client):
            """
            GIVEN: An unassigned task
            WHEN: Two operators try to claim it simultaneously
            THEN: Only one succeeds, the other gets 409 Conflict
            """
            dept = DepartmentFactory()
            operator1 = UserFactory(username='op1', department=dept, role='operator')
            operator2 = UserFactory(username='op2', department=dept, role='operator')

            task = WorkOrderTaskFactory(
                status='pending',
                assigned_department=dept
            )

            results = {'success': 0, 'failed': 0, 'errors': []}

            def claim_task(user):
                client = APIClient()
                client.force_authenticate(user=user)
                try:
                    response = client.post(f'/api/tasks/{task.id}/claim/')
                    if response.status_code == status.HTTP_200_OK:
                        results['success'] += 1
                    else:
                        results['failed'] += 1
                        results['errors'].append(response.status_code)
                except Exception as e:
                    results['failed'] += 1
                    results['errors'].append(str(e))

            # Simulate concurrent claims
            t1 = threading.Thread(target=claim_task, args=(operator1,))
            t2 = threading.Thread(target=claim_task, args=(operator2,))
            t1.start(), t2.start()
            t1.join(), t2.join()

            # Assert: Only one claim succeeded
            assert results['success'] == 1
            assert results['failed'] == 1

            task.refresh_from_db()
            assert task.assigned_operator in [operator1, operator2]

        def test_task_completion_updates_status(self, api_client):
            """
            GIVEN: A task assigned to an operator
            WHEN: Operator marks task as complete
            THEN: Task status changes to completed
            """
            dept = DepartmentFactory()
            operator = UserFactory(username='operator', department=dept, role='operator')

            task = WorkOrderTaskFactory(
                status='in_progress',
                assigned_operator=operator,
                assigned_department=dept
            )

            api_client.force_authenticate(user=operator)
            response = api_client.post(f'/api/tasks/{task.id}/complete/', {
                'completion_quantity': task.quantity,
                'notes': 'Task completed'
            }, format='json')

            assert response.status_code == status.HTTP_200_OK
            task.refresh_from_db()
            assert task.status == 'completed'

        def test_unauthorized_task_assignment_fails(self, api_client):
            """
            GIVEN: A pending task
            WHEN: Non-supervisor tries to assign it
            THEN: Request fails with 403 Forbidden
            """
            dept = DepartmentFactory()
            operator = UserFactory(username='operator', department=dept, role='operator')
            other_operator = UserFactory(username='other_op', department=dept, role='operator')

            task = WorkOrderTaskFactory(status='pending', assigned_department=dept)

            # Operator tries to assign (should fail)
            api_client.force_authenticate(user=operator)
            response = api_client.post(f'/api/tasks/{task.id}/assign/', {
                'operator_id': other_operator.id
            }, format='json')

            assert response.status_code == status.HTTP_403_FORBIDDEN

        def test_task_capacity_limit_enforced(self, api_client):
            """
            GIVEN: An operator at maximum capacity
            WHEN: Supervisor tries to assign another task
            THEN: Assignment fails with capacity error
            """
            dept = DepartmentFactory()
            supervisor = UserFactory(username='supervisor', department=dept, role='supervisor')
            operator = UserFactory(username='operator', department=dept, role='operator')

            # Assign operator to max tasks (default 10)
            for _ in range(10):
                WorkOrderTaskFactory(
                    status='in_progress',
                    assigned_operator=operator,
                    assigned_department=dept
                )

            # Try to assign one more
            new_task = WorkOrderTaskFactory(status='pending', assigned_department=dept)

            api_client.force_authenticate(user=supervisor)
            response = api_client.post(f'/api/tasks/{new_task.id}/assign/', {
                'operator_id': operator.id
            }, format='json')

            assert response.status_code == status.HTTP_400_BAD_REQUEST
            assert 'capacity' in str(response.data).lower()
    ```

    These tests cover the complete task lifecycle with error cases, concurrency, and permission checks.
  </action>
  <verify>
    cd backend && pytest workorder/tests/integration/test_task_workflows.py -v --tb=short
  </verify>
  <done>
    All task workflow tests pass, covering approval, rejection, assignment, claiming, completion, and error cases
  </done>
</task>

<task type="auto">
  <name>Create work order lifecycle integration tests</name>
  <files>backend/workorder/tests/integration/test_workorder_lifecycle.py</files>
  <action>
    Create backend/workorder/tests/integration/test_workorder_lifecycle.py testing the complete work order lifecycle:

    ```python
    """Integration tests for complete work order lifecycle"""
    import pytest
    from rest_framework import status
    from rest_framework.test import APIClient
    from workorder.tests.factories import (
        WorkOrderFactory, UserFactory, DepartmentFactory, ProcessFactory,
        WorkOrderProcessFactory, CustomerFactory, ProductFactory
    )
    from workorder.models import WorkOrder

    @pytest.mark.django_db
    @pytest.mark.integration
    class TestWorkOrderLifecycle:
        """Test complete work order lifecycle from creation to completion"""

        def test_full_workorder_lifecycle(self, api_client):
            """
            GIVEN: A new work order
            WHEN: Following the complete lifecycle (create -> approve -> dispatch -> complete)
            THEN: All transitions work correctly
            """
            # Setup
            dept = DepartmentFactory(name='Printing')
            process = ProcessFactory(name='Offset Printing', department=dept)
            maker = UserFactory(username='maker', department=dept, role='maker')
            supervisor = UserFactory(username='supervisor', department=dept, role='supervisor')
            operator = UserFactory(username='operator', department=dept, role='operator')
            customer = CustomerFactory(name='Test Customer')
            product = ProductFactory()

            # Step 1: Create workorder with draft tasks
            api_client.force_authenticate(user=maker)
            response = api_client.post('/api/workorders/', {
                'customer': customer.id,
                'production_quantity': 100,
                'delivery_date': '2026-12-31',
                'priority': 'normal',
                'products': [{'product': product.id, 'quantity': 100}],
                'processes': [{'process': process.id, 'sequence': 10}]
            }, format='json')

            assert response.status_code == status.HTTP_201_CREATED
            workorder_id = response.data['id']
            workorder = WorkOrder.objects.get(id=workorder_id)

            # Verify draft tasks were created
            draft_tasks = workorder.tasks.filter(status='draft')
            assert draft_tasks.count() > 0

            # Step 2: Approve workorder
            api_client.force_authenticate(user=supervisor)
            response = api_client.post(f'/api/workorders/{workorder_id}/approve/')

            assert response.status_code == status.HTTP_200_OK
            workorder.refresh_from_db()
            assert workorder.approval_status == 'approved'

            # Verify tasks converted to pending
            tasks = workorder.tasks.filter(status='pending')
            assert tasks.count() == draft_tasks.count()

            # Step 3: Auto-dispatch (tasks assigned to department)
            task = tasks.first()
            assert task.assigned_department == dept

            # Step 4: Supervisor assigns task to operator
            response = api_client.post(f'/api/tasks/{task.id}/assign/', {
                'operator_id': operator.id
            }, format='json')

            assert response.status_code == status.HTTP_200_OK
            task.refresh_from_db()
            assert task.assigned_operator == operator

            # Step 5: Operator starts task
            api_client.force_authenticate(user=operator)
            response = api_client.post(f'/api/tasks/{task.id}/start/')

            assert response.status_code == status.HTTP_200_OK
            task.refresh_from_db()
            assert task.status == 'in_progress'

            # Step 6: Operator completes task
            response = api_client.post(f'/api/tasks/{task.id}/complete/', {
                'completion_quantity': 100,
                'defective_quantity': 0
            }, format='json')

            assert response.status_code == status.HTTP_200_OK
            task.refresh_from_db()
            assert task.status == 'completed'

        def test_workorder_with_multiple_processes(self, api_client):
            """
            GIVEN: A workorder with multiple processes
            WHEN: Workorder is approved
            THEN: Tasks are generated for all processes
            """
            dept = DepartmentFactory()
            process1 = ProcessFactory(name='CTP', department=dept)
            process2 = ProcessFactory(name='Printing', department=dept)
            process3 = ProcessFactory(name='Die Cutting', department=dept)

            maker = UserFactory(username='maker', department=dept, role='maker')
            supervisor = UserFactory(username='supervisor', department=dept, role='supervisor')
            customer = CustomerFactory()

            api_client.force_authenticate(user=maker)
            response = api_client.post('/api/workorders/', {
                'customer': customer.id,
                'production_quantity': 500,
                'delivery_date': '2026-12-31',
                'processes': [
                    {'process': process1.id, 'sequence': 10},
                    {'process': process2.id, 'sequence': 20},
                    {'process': process3.id, 'sequence': 30},
                ]
            }, format='json')

            assert response.status_code == status.HTTP_201_CREATED
            workorder_id = response.data['id']

            # Approve
            api_client.force_authenticate(user=supervisor)
            api_client.post(f'/api/workorders/{workorder_id}/approve/')

            # Verify tasks for all processes
            workorder = WorkOrder.objects.get(id=workorder_id)
            tasks = workorder.tasks.filter(status='pending')
            assert tasks.count() >= 3  # At least one task per process

        def test_workorder_edit_before_approval(self, api_client):
            """
            GIVEN: A draft workorder
            WHEN: Maker edits processes
            THEN: Tasks are synced with new processes
            """
            dept = DepartmentFactory()
            process1 = ProcessFactory(name='CTP', department=dept)
            process2 = ProcessFactory(name='Printing', department=dept)

            maker = UserFactory(username='maker', department=dept, role='maker')
            customer = CustomerFactory()

            # Create workorder
            api_client.force_authenticate(user=maker)
            response = api_client.post('/api/workorders/', {
                'customer': customer.id,
                'production_quantity': 100,
                'processes': [
                    {'process': process1.id, 'sequence': 10},
                ]
            }, format='json')

            workorder_id = response.data['id']
            initial_task_count = WorkOrder.objects.get(id=workorder_id).tasks.count()

            # Edit to add process
            response = api_client.patch(f'/api/workorders/{workorder_id}/', {
                'processes': [
                    {'process': process1.id, 'sequence': 10},
                    {'process': process2.id, 'sequence': 20},
                ]
            }, format='json')

            assert response.status_code == status.HTTP_200_OK
            workorder = WorkOrder.objects.get(id=workorder_id)

            # After sync, should have more tasks
            assert workorder.tasks.count() > initial_task_count

        def test_workorder_cannot_edit_after_approval(self, api_client):
            """
            GIVEN: An approved workorder
            WHEN: Maker tries to edit it
            THEN: Edit fails with validation error
            """
            dept = DepartmentFactory()
            maker = UserFactory(username='maker', department=dept, role='maker')
            supervisor = UserFactory(username='supervisor', department=dept, role='supervisor')
            customer = CustomerFactory()

            # Create and approve
            api_client.force_authenticate(user=maker)
            response = api_client.post('/api/workorders/', {
                'customer': customer.id,
                'production_quantity': 100,
            }, format='json')

            workorder_id = response.data['id']

            api_client.force_authenticate(user=supervisor)
            api_client.post(f'/api/workorders/{workorder_id}/approve/')

            # Try to edit
            api_client.force_authenticate(user=maker)
            response = api_client.patch(f'/api/workorders/{workorder_id}/', {
                'production_quantity': 200
            }, format='json')

            assert response.status_code == status.HTTP_400_BAD_REQUEST
            assert 'approved' in str(response.data).lower()
    ```

    These tests verify the complete work order lifecycle with multi-process scenarios.
  </action>
  <verify>
    cd backend && pytest workorder/tests/integration/test_workorder_lifecycle.py -v --tb=short
  </verify>
  <done>
    All lifecycle tests pass, covering creation, multi-process, editing, and approval constraints
  </done>
</task>

<task type="auto">
  <name>Create notification and dispatch workflow tests</name>
  <files>backend/workorder/tests/integration/test_notification_workflows.py, backend/workorder/tests/integration/test_dispatch_workflows.py</files>
  <action>
    Create two test files for notification and dispatch workflows:

    1. Create backend/workorder/tests/integration/test_notification_workflows.py:
    ```python
    """Integration tests for notification workflows"""
    import pytest
    from rest_framework import status
    from rest_framework.test import APIClient
    from workorder.tests.factories import (
        WorkOrderFactory, UserFactory, DepartmentFactory, WorkOrderTaskFactory
    )
    from workorder.models import Notification

    @pytest.mark.django_db
    @pytest.mark.integration
    class TestNotificationWorkflows:
        """Test notification creation and delivery on task events"""

        def test_task_assignment_creates_notification(self, api_client):
            """
            GIVEN: A task and an operator
            WHEN: Supervisor assigns the task
            THEN: Operator receives a notification
            """
            dept = DepartmentFactory()
            supervisor = UserFactory(username='supervisor', department=dept, role='supervisor')
            operator = UserFactory(username='operator', department=dept, role='operator')

            task = WorkOrderTaskFactory(status='pending', assigned_department=dept)

            api_client.force_authenticate(user=supervisor)
            response = api_client.post(f'/api/tasks/{task.id}/assign/', {
                'operator_id': operator.id
            }, format='json')

            assert response.status_code == status.HTTP_200_OK

            # Verify notification was created
            notifications = Notification.objects.filter(
                recipient=operator,
                notification_type='task_assigned'
            )
            assert notifications.count() > 0

        def test_task_completion_creates_notification(self, api_client):
            """
            GIVEN: An in-progress task
            WHEN: Operator completes the task
            THEN: Supervisor receives a notification
            """
            dept = DepartmentFactory()
            supervisor = UserFactory(username='supervisor', department=dept, role='supervisor')
            operator = UserFactory(username='operator', department=dept, role='operator')

            task = WorkOrderTaskFactory(
                status='in_progress',
                assigned_operator=operator,
                assigned_department=dept
            )

            api_client.force_authenticate(user=operator)
            response = api_client.post(f'/api/tasks/{task.id}/complete/', {
                'completion_quantity': task.quantity
            }, format='json')

            assert response.status_code == status.HTTP_200_OK

            # Verify supervisor notification
            notifications = Notification.objects.filter(
                notification_type='task_completed'
            ).filter(
                recipient__profile__role='supervisor'
            )
            assert notifications.count() > 0

        def test_notification_list_filters_by_user(self, api_client):
            """
            GIVEN: Multiple notifications for different users
            WHEN: User requests their notifications
            THEN: Only their notifications are returned
            """
            dept = DepartmentFactory()
            user1 = UserFactory(username='user1', department=dept)
            user2 = UserFactory(username='user2', department=dept)

            # Create notifications for user1
            for _ in range(3):
                Notification.objects.create(
                    recipient=user1,
                    notification_type='task_assigned',
                    title='Test notification',
                    message='Test message'
                )

            # Create notifications for user2
            for _ in range(5):
                Notification.objects.create(
                    recipient=user2,
                    notification_type='task_assigned',
                    title='Test notification',
                    message='Test message'
                )

            # User1 requests notifications
            api_client.force_authenticate(user=user1)
            response = api_client.get('/api/notifications/')

            assert response.status_code == status.HTTP_200_OK
            # User1 should only see their 3 notifications
            assert response.data['count'] == 3

        def test_mark_notification_as_read(self, api_client):
            """
            GIVEN: An unread notification
            WHEN: User marks it as read
            THEN: Notification is_read becomes True
            """
            user = UserFactory(username='user1')
            notification = Notification.objects.create(
                recipient=user,
                notification_type='task_assigned',
                title='Test',
                message='Test message',
                is_read=False
            )

            api_client.force_authenticate(user=user)
            response = api_client.post(f'/api/notifications/{notification.id}/mark_read/')

            assert response.status_code == status.HTTP_200_OK
            notification.refresh_from_db()
            assert notification.is_read is True
    ```

    2. Create backend/workorder/tests/integration/test_dispatch_workflows.py:
    ```python
    """Integration tests for auto-dispatch workflows"""
    import pytest
    from rest_framework import status
    from rest_framework.test import APIClient
    from workorder.tests.factories import (
        WorkOrderFactory, UserFactory, DepartmentFactory, ProcessFactory,
        WorkOrderProcessFactory
    )
    from workorder.models import TaskAssignmentRule, WorkOrderTask

    @pytest.mark.django_db
    @pytest.mark.integration
    class TestAutoDispatchWorkflow:
        """Test automatic task dispatch on workorder approval"""

        def test_auto_dispatch_on_approval(self, api_client):
            """
            GIVEN: A workorder with dispatch rules configured
            WHEN: Supervisor approves the workorder
            THEN: Tasks are dispatched to highest-priority department
            """
            # Setup: Create departments with priority
            dept1 = DepartmentFactory(name='Printing Dept A', code='PRT001')
            dept2 = DepartmentFactory(name='Printing Dept B', code='PRT002')

            process = ProcessFactory(name='Offset Printing')

            # Configure dispatch rules
            TaskAssignmentRule.objects.create(
                process=process,
                department=dept1,
                priority=1
            )
            TaskAssignmentRule.objects.create(
                process=process,
                department=dept2,
                priority=2
            )

            # Create workorder
            supervisor = UserFactory(username='supervisor', department=dept1, role='supervisor')
            maker = UserFactory(username='maker', department=dept1, role='maker')

            workorder = WorkOrderFactory(
                approval_status='submitted',
                created_by=maker
            )

            WorkOrderProcessFactory(
                work_order=workorder,
                process=process,
                tasks=3
            )

            # Approve workorder
            api_client.force_authenticate(user=supervisor)
            response = api_client.post(f'/api/workorders/{workorder.id}/approve/')

            assert response.status_code == status.HTTP_200_OK

            # Verify tasks dispatched to dept1 (highest priority)
            tasks = WorkOrderTask.objects.filter(work_order=workorder)
            assert tasks.count() == 3
            assert all(task.assigned_department == dept1 for task in tasks)

        def test_load_balancing_dispatch(self, api_client):
            """
            GIVEN: Two departments with equal priority
            WHEN: Tasks are dispatched
            THEN: Tasks go to the department with lower load
            """
            dept1 = DepartmentFactory(name='Dept A')
            dept2 = DepartmentFactory(name='Dept B')
            process = ProcessFactory(name='Test Process')

            # Equal priority
            TaskAssignmentRule.objects.create(process=process, department=dept1, priority=1)
            TaskAssignmentRule.objects.create(process=process, department=dept2, priority=1)

            # Add existing tasks to dept1 to increase load
            operator = UserFactory(username='op', department=dept1, role='operator')
            for _ in range(5):
                WorkOrderTaskFactory(
                    status='in_progress',
                    assigned_department=dept1,
                    assigned_operator=operator
                )

            # Create and approve workorder
            supervisor = UserFactory(username='supervisor', department=dept1, role='supervisor')
            workorder = WorkOrderFactory(approval_status='submitted')
            WorkOrderProcessFactory(work_order=workorder, process=process, tasks=1)

            api_client.force_authenticate(user=supervisor)
            api_client.post(f'/api/workorders/{workorder.id}/approve/')

            # Verify task went to dept2 (lower load)
            task = WorkOrderTask.objects.filter(work_order=workorder).first()
            assert task.assigned_department == dept2

        def test_dispatch_with_disabled_rule(self, api_client):
            """
            GIVEN: A dispatch rule that is disabled
            WHEN: Workorder is approved
            THEN: Task is not dispatched to that department
            """
            dept1 = DepartmentFactory(name='Active Dept')
            dept2 = DepartmentFactory(name='Disabled Dept')
            process = ProcessFactory(name='Test Process')

            # dept2 rule is disabled
            TaskAssignmentRule.objects.create(
                process=process,
                department=dept1,
                priority=1,
                is_enabled=True
            )
            TaskAssignmentRule.objects.create(
                process=process,
                department=dept2,
                priority=0,  # Higher priority but disabled
                is_enabled=False
            )

            supervisor = UserFactory(username='supervisor', department=dept1, role='supervisor')
            workorder = WorkOrderFactory(approval_status='submitted')
            WorkOrderProcessFactory(work_order=workorder, process=process, tasks=1)

            api_client.force_authenticate(user=supervisor)
            api_client.post(f'/api/workorders/{workorder.id}/approve/')

            # Task goes to dept1, not dept2
            task = WorkOrderTask.objects.filter(work_order=workorder).first()
            assert task.assigned_department == dept1
    ```

    These tests verify notification generation and auto-dispatch logic with priority and load balancing.
  </action>
  <verify>
    cd backend && pytest workorder/tests/integration/test_notification_workflows.py workorder/tests/integration/test_dispatch_workflows.py -v --tb=short
  </verify>
  <done>
    All notification and dispatch tests pass, verifying notifications are created and dispatch rules work correctly
  </done>
</task>

<task type="auto">
  <name>Run full test suite and verify coverage</name>
  <files>backend/workorder/tests/</files>
  <action>
    Run the complete test suite with coverage measurement to verify >80% coverage:

    1. Run all integration tests:
    ```bash
    cd backend
    pytest workorder/tests/integration/ -v --cov=workorder --cov-report=term-missing --cov-report=html
    ```

    2. Run all existing tests alongside new integration tests:
    ```bash
    pytest workorder/tests/ -v --cov=workorder --cov-report=term-missing --cov-report=html
    ```

    3. Verify the coverage report meets the 80% threshold. The coverage report will be in:
    - Terminal output with missing lines
    - HTML report at backend/htmlcov/index.html

    4. Fix any failing tests by:
    - Checking API endpoint paths match actual URLs
    - Verifying factory relationships are correct
    - Ensuring test data matches validation rules
    - Adjusting assertions to match actual behavior

    5. If coverage is below 80%, add tests for uncovered paths:
    - Error handling paths (400, 403, 404 responses)
    - Edge cases (empty lists, null values, maximum values)
    - Additional permission scenarios

    6. Create a test runner script at backend/run_tests.sh:
    ```bash
    #!/bin/bash
    set -e
    cd "$(dirname "$0")"
    echo "Running tests with coverage..."
    pytest workorder/tests/ -v --cov=workorder --cov-report=term-missing --cov-report=html --cov-fail-under=80
    echo "Test coverage report generated: htmlcov/index.html"
    ```

    This ensures the test suite runs correctly and coverage meets the quality gate threshold.
  </action>
  <verify>
    cd backend && pytest workorder/tests/ --cov=workorder --cov-report=term-missing --cov-fail-under=80
  </verify>
  <done>
    All tests pass and coverage exceeds 80% for workorder module
  </done>
</task>

</tasks>

<verification>
After completing all tasks, verify:

1. pytest discovers and runs all new integration tests
2. All tests pass with no failures
3. Coverage report shows >80% coverage
4. Tests run in isolation (order-independent)
5. Factories create valid test data
6. Concurrent claiming test passes with threading
7. Permission tests validate role-based access
8. Error paths are tested (403, 404, 409 responses)
</verification>

<success_criteria>
- All integration tests pass when run with pytest
- Test coverage measured at >80% for workorder module
- Tests use factory_boy for test data generation
- Concurrent scenario tests pass with threading
- Full lifecycle test creates workorder, approves, assigns, and completes
- Notification tests verify notifications are created on task events
- Dispatch tests verify priority and load balancing logic
</success_criteria>

<output>
After completion, create `.planning/phases/10-production-hardening/10-01-SUMMARY.md` with:
- Number of integration tests created
- Final coverage percentage
- Any issues encountered and resolved
- Test execution time
</output>
