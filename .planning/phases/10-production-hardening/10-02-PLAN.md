---
phase: 10-production-hardening
plan: 02
type: execute
wave: 2
depends_on: []
files_modified:
  - backend/requirements.txt
  - backend/config/settings.py
  - backend/config/urls.py
  - backend/workorder/views/
  - backend/docs/api/openapi.json
  - backend/docs/api/openapi.yaml
  - backend/docs/api/README.md
  - docs/API.md
  - docs/USER_MANUAL.md
  - docs/DEPLOYMENT.md
autonomous: true

must_haves:
  truths:
    - "drf-spectacular generates OpenAPI 3.0 schema for all API endpoints"
    - "Swagger UI is accessible at /api/docs/ for interactive API exploration"
    - "API documentation covers all task-related endpoints with parameters and responses"
    - "User manual documents all features in Chinese with step-by-step instructions"
    - "Deployment checklist includes backups, monitoring, and environment configuration"
    - "API docs are auto-generated and stay in sync with code changes"
  artifacts:
    - path: "backend/requirements.txt"
      provides: "drf-spectacular dependency"
      contains: "drf-spectacular"
    - path: "backend/config/settings.py"
      provides: "drf-spectacular configuration"
      contains: "SPECTACULAR_SETTINGS"
    - path: "backend/config/urls.py"
      provides: "API documentation URLs"
      contains: "SpectacularAPIView"
    - path: "backend/docs/api/openapi.json"
      provides: "Generated OpenAPI 3.0 schema"
      contains: "openapi"
    - path: "backend/docs/api/openapi.yaml"
      provides: "YAML format schema"
      contains: "openapi"
    - path: "backend/docs/api/README.md"
      provides: "API documentation guide"
      contains: "# API"
    - path: "docs/API.md"
      provides: "Comprehensive API documentation in Chinese"
      contains: "# API"
    - path: "docs/USER_MANUAL.md"
      provides: "User manual in Chinese"
      contains: "# 用户手册"
    - path: "docs/DEPLOYMENT.md"
      provides: "Deployment guide with checklist"
      contains: "# 部署指南"
  key_links:
    - from: "backend/config/urls.py"
      to: "drf-spectacular views"
      via: "SpectacularAPIView import"
      pattern: "from drf_spectacular\\.views import"
    - from: "backend/config/settings.py"
      to: "drf-spectacular settings"
      via: "REST_FRAMEWORK and SPECTACULAR_SETTINGS"
      pattern: "SPECTACULAR_SETTINGS"
    - from: "ViewSets"
      to: "OpenAPI schema"
      via: "@extend_schema decorator"
      pattern: "@extend_schema"
    - from: "docs/ directory"
      to: "backend/docs/api/"
      via: "API documentation references"
      pattern: "backend/docs/api"
---

<objective>
Create comprehensive API documentation using drf-spectacular (OpenAPI 3.0) and a complete user manual in Chinese. The API documentation will be auto-generated from code annotations, ensuring it stays synchronized with the codebase. The user manual will provide step-by-step instructions for all system features.

Purpose: Good documentation enables developers to integrate with the API efficiently and helps users understand and use the system without constant support. Auto-generated API docs prevent documentation drift.

Output: Interactive Swagger UI at /api/docs/, downloadable OpenAPI schema files, comprehensive API documentation in Markdown, and a complete Chinese user manual.
</objective>

<execution_context>
@/home/chenjiaxing/.claude/get-shit-done/workflows/execute-plan.md
@/home/chenjiaxing/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-production-hardening/10-CONTEXT.md
@.planning/phases/10-production-hardening/10-RESEARCH.md
@backend/workorder/views/
@backend/config/urls.py
@backend/config/settings.py
@docs/DEPLOYMENT.md
</context>

<tasks>

<task type="auto">
  <name>Install and configure drf-spectacular</name>
  <files>backend/requirements.txt, backend/config/settings.py, backend/config/urls.py</files>
  <action>
    1. Add drf-spectacular to backend/requirements.txt:
    ```
    # API Documentation
    drf-spectacular==0.27.0
    ```

    2. Update backend/config/settings.py to configure drf-spectacular:

    First, add to INSTALLED_APPS:
    ```python
    INSTALLED_APPS = [
        # ...
        'rest_framework',
        'drf_spectacular',  # Add this
        # ...
    ]
    ```

    Then add to REST_FRAMEWORK configuration:
    ```python
    REST_FRAMEWORK = {
        'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
        # ... existing settings
    }
    ```

    Finally, add drf-spectacular settings at the end of settings.py:
    ```python
    # drf-spectacular API documentation settings
    SPECTACULAR_SETTINGS = {
        'TITLE': '印刷施工单跟踪系统 API',
        'DESCRIPTION': '''
        施工单任务即时分派和跟踪管理系统 API 文档。

        ## 主要功能
        - **施工单管理**: 创建、编辑、审核施工单
        - **任务管理**: 任务分派、认领、进度跟踪
        - **部门管理**: 部门工序配置、优先级设置
        - **实时通知**: WebSocket 任务事件通知
        - **统计分析**: 任务统计、部门负载、协作分析

        ## 认证方式
        API 使用 Token 认证。在请求头中包含:
        ```
        Authorization: Token your_token_here
        ```
        ''',
        'VERSION': '1.0.0',
        'SERVE_INCLUDE_SCHEMA': False,
        'COMPONENT_SPLIT_REQUEST': True,
        'COMPONENT_NO_READ_ONLY_REQUIRED': True,
        'TAGS': [
            {'name': '施工单', 'description': '施工单的创建、编辑、审核和查询'},
            {'name': '任务', 'description': '任务的分派、认领、更新和完成'},
            {'name': '部门', 'description': '部门信息和工序配置'},
            {'name': '工序', 'description': '工序类型和属性管理'},
            {'name': '用户', 'description': '用户信息和权限管理'},
            {'name': '通知', 'description': '实时通知和历史记录'},
            {'name': '统计', 'description': '任务统计和数据分析'},
            {'name': '产品', 'description': '产品信息和库存管理'},
            {'name': '物料', 'description': '物料信息和采购管理'},
            {'name': '客户', 'description': '客户信息和联系记录'},
        ],
        'SCHEMA_PATH_PREFIX': '/api',
        'SCHEMA_PATH_PREFIX_TRIM': True,
    }
    ```

    3. Update backend/config/urls.py to add API documentation endpoints:
    ```python
    from drf_spectacular.views import (
        SpectacularAPIView,
        SpectacularRedocView,
        SpectacularSwaggerView,
    )

    urlpatterns = [
        # ... existing URL patterns ...

        # API documentation (add these)
        path('api/schema/', SpectacularAPIView.as_view(), name='schema'),
        path('api/docs/', SpectacularSwaggerView.as_view(url_name='schema'), name='swagger-ui'),
        path('api/redoc/', SpectacularRedocView.as_view(url_name='schema'), name='redoc'),
    ]
    ```

    4. Install the package:
    ```bash
    cd backend && pip install drf-spectacular==0.27.0
    ```

    This configures drf-spectacular to auto-generate OpenAPI 3.0 schema with Chinese descriptions for all DRF ViewSets.
  </action>
  <verify>
    cd backend && python manage.py spectacular --color --file schema.yml 2>&1 | head -20
  </verify>
  <done>
    drf-spectacular is installed and generates OpenAPI schema successfully
  </done>
</task>

<task type="auto">
  <name>Add OpenAPI decorators to task-related ViewSets</name>
  <files>backend/workorder/views/work_order_tasks/task_main.py, backend/workorder/views/work_order_tasks/task_actions.py, backend/workorder/views/work_orders.py, backend/workorder/views/notification.py</files>
  <action>
    Add drf-spectacular's @extend_schema decorators to the most important ViewSets for better API documentation:

    1. Update backend/workorder/views/work_order_tasks/task_main.py:

    At the top, add imports:
    ```python
    from drf_spectacular.utils import extend_schema, extend_schema_view, OpenApiParameter, OpenApiResponse
    from drf_spectacular.types import OpenApiTypes
    ```

    Add decorator to the WorkOrderTaskViewSet class:
    ```python
    @extend_schema_view(
        list=extend_schema(
            tags=['任务'],
            summary='获取任务列表',
            description='返回分页的任务列表，支持按部门、状态、操作员等条件筛选。',
            parameters=[
                OpenApiParameter(
                    name='assigned_department',
                    type=OpenApiTypes.INT,
                    description='按部门ID筛选',
                    required=False,
                ),
                OpenApiParameter(
                    name='status',
                    type=OpenApiTypes.STR,
                    description='按任务状态筛选',
                    enum=['draft', 'pending', 'in_progress', 'completed', 'cancelled'],
                    required=False,
                ),
                OpenApiParameter(
                    name='assigned_operator',
                    type=OpenApiTypes.INT,
                    description='按操作员ID筛选',
                    required=False,
                ),
                OpenApiParameter(
                    name='search',
                    type=OpenApiTypes.STR,
                    description='搜索任务编号、施工单号或工作内容',
                    required=False,
                ),
            ],
            responses={200: WorkOrderTaskSerializer},
        ),
        retrieve=extend_schema(
            tags=['任务'],
            summary='获取任务详情',
            description='获取指定任务的完整信息，包括关联的施工单、工序、部门和操作员。',
            responses={200: WorkOrderTaskSerializer, 404: OpenApiResponse(description='任务不存在')},
        ),
        destroy=extend_schema(
            tags=['任务'],
            summary='删除任务',
            description='删除指定的任务。只有草稿状态的任务可以被删除。',
            responses={204: OpenApiResponse(description='删除成功'), 400: OpenApiResponse(description='无法删除非草稿任务')},
        ),
    )
    class WorkOrderTaskViewSet(viewsets.ModelViewSet):
        # ... existing code ...
    ```

    2. Update backend/workorder/views/work_order_tasks/task_actions.py to document custom actions:

    ```python
    from drf_spectacular.utils import extend_schema, OpenApiResponse, inline_serializer
    from rest_framework import serializers
    from drf_spectacular.types import OpenApiTypes

    # In TaskActionsMixin, update the assign action:

    @extend_schema(
        tags=['任务'],
        summary='分配任务给操作员',
        description='''
        部门主管将任务分配给指定操作员。

        **权限要求**: 只有部门主管或有相应权限的用户可以分配任务。

        **业务规则**:
        - 只能分配本部门的任务
        - 只能分配 pending 或 in_progress 状态的任务
        - 操作员不能超过最大任务数量限制（默认10个）
        ''',
        request=inline_serializer(
            name='TaskAssignRequest',
            fields={
                'operator_id': serializers.IntegerField(help_text='操作员ID'),
                'notes': serializers.CharField(required=False, allow_blank=True, help_text='备注信息'),
            }
        ),
        responses={
            200: OpenApiResponse(description='分配成功'),
            400: OpenApiResponse(description='请求无效或操作员任务数量已满'),
            403: OpenApiResponse(description='权限不足'),
            404: OpenApiResponse(description='任务或操作员不存在'),
        },
    )
    @action(detail=True, methods=['post'])
    def assign(self, request, pk=None):
        # ... existing code ...

    # Add documentation for claim action:

    @extend_schema(
        tags=['任务'],
        summary='认领任务',
        description='''
        操作员认领一个未分配的任务。

        **权限要求**: 只有部门成员可以认领本部门的任务。

        **并发控制**: 使用行级锁防止多个操作员同时认领同一任务。
        ''',
        responses={
            200: OpenApiResponse(description='认领成功'),
            400: OpenApiResponse(description='任务已被分配或不在本部门'),
            409: OpenApiResponse(description='并发冲突，任务已被其他操作员认领'),
        },
    )
    @action(detail=True, methods=['post'])
    def claim(self, request, pk=None):
        # ... existing code ...

    # Add documentation for complete action:

    @extend_schema(
        tags=['任务'],
        summary='完成任务',
        description='''
        操作员标记任务为完成状态。

        **业务规则**:
        - 完成数量不能超过任务数量
        - 可记录次品数量
        - 任务状态变更为 completed
        ''',
        request=inline_serializer(
            name='TaskCompleteRequest',
            fields={
                'completion_quantity': serializers.IntegerField(help_text='完成数量'),
                'defective_quantity': serializers.IntegerField(required=False, default=0, help_text='次品数量'),
                'notes': serializers.CharField(required=False, allow_blank=True, help_text='完成说明'),
            }
        ),
        responses={
            200: OpenApiResponse(description='任务完成'),
            400: OpenApiResponse(description='完成数量超过任务数量'),
        },
    )
    @action(detail=True, methods=['post'])
    def complete(self, request, pk=None):
        # ... existing code ...
    ```

    3. Update backend/workorder/views/work_orders.py for work order endpoints:

    ```python
    from drf_spectacular.utils import extend_schema, OpenApiResponse

    @extend_schema_view(
        list=extend_schema(
            tags=['施工单'],
            summary='获取施工单列表',
            description='返回分页的施工单列表，支持按客户、状态、优先级等条件筛选。',
        ),
        create=extend_schema(
            tags=['施工单'],
            summary='创建施工单',
            description='创建新的施工单，自动生成所有工序的草稿任务。',
        ),
        retrieve=extend_schema(
            tags=['施工单'],
            summary='获取施工单详情',
            description='获取施工单的完整信息，包括关联的任务、产品和工序。',
        ),
    )
    class WorkOrderViewSet(viewsets.ModelViewSet):
        # ... existing code ...

    @extend_schema(
        tags=['施工单'],
        summary='审核通过施工单',
        description='''
        主管审核通过施工单。

        **效果**:
        - 所有草稿任务转换为正式任务（pending状态）
        - 根据分派规则自动分配到部门
        - 施工单状态变更为 approved
        ''',
        responses={
            200: OpenApiResponse(description='审核通过'),
            400: OpenApiResponse(description='施工单状态不正确'),
        },
    )
    @action(detail=True, methods=['post'])
    def approve(self, request, pk=None):
        # ... existing code ...
    ```

    4. Update backend/workorder/views/notification.py:

    ```python
    @extend_schema_view(
        list=extend_schema(
            tags=['通知'],
            summary='获取通知列表',
            description='返回当前用户的通知列表，仅显示最近30天的通知。',
        ),
        partial_update=extend_schema(
            tags=['通知'],
            summary='标记通知为已读',
            description='将指定通知标记为已读状态。',
        ),
    )
    class NotificationViewSet(viewsets.ModelViewSet):
        # ... existing code ...
    ```

    These decorators provide clear Chinese documentation for each API endpoint in the Swagger UI.
  </action>
  <verify>
    cd backend && python manage.py spectacular --color --file - 2>&1 | grep -A5 "tags:\|summary:" | head -40
  </verify>
  <done>
    All task-related endpoints have Chinese descriptions in OpenAPI schema
  </done>
</task>

<task type="auto">
  <name>Generate and export OpenAPI schema files</name>
  <files>backend/docs/api/openapi.json, backend/docs/api/openapi.yaml, backend/docs/api/README.md</files>
  <action>
    1. Create the backend/docs/api directory:
    ```bash
    mkdir -p backend/docs/api
    ```

    2. Generate OpenAPI schema files in both JSON and YAML formats:
    ```bash
    cd backend
    python manage.py spectacular --color --file docs/api/openapi.yaml --format yaml
    python manage.py spectacular --color --file docs/api/openapi.json --format json
    ```

    3. Create backend/docs/api/README.md:
    ```markdown
    # 印刷施工单跟踪系统 API 文档

    ## 概述

    本系统提供 RESTful API 用于施工单和任务管理。API 文档使用 OpenAPI 3.0 规范编写。

    ## 在线文档

    开发环境启动后，可访问以下地址查看交互式 API 文档：

    - **Swagger UI**: http://localhost:8000/api/docs/
    - **ReDoc**: http://localhost:8000/api/redoc/
    - **OpenAPI Schema**: http://localhost:8000/api/schema/

    ## Schema 文件

    - `openapi.yaml` - OpenAPI 3.0 规范（YAML 格式）
    - `openapi.json` - OpenAPI 3.0 规范（JSON 格式）

    ## 认证方式

    API 使用 Token 认证。在请求头中包含：

    ```
    Authorization: Token your_token_here
    ```

    获取 Token：
    ```bash
    curl -X POST http://localhost:8000/api/auth/login/ \\
      -H "Content-Type: application/json" \\
      -d '{"username": "your_username", "password": "your_password"}'
    ```

    响应：
    ```json
    {
      "token": "your_auth_token",
      "user_id": 1,
      "username": "your_username"
    }
    ```

    ## API 端点分类

    ### 施工单 (WorkOrders)
    - `GET /api/workorders/` - 获取施工单列表
    - `POST /api/workorders/` - 创建施工单
    - `GET /api/workorders/{id}/` - 获取施工单详情
    - `PUT /api/workorders/{id}/` - 更新施工单
    - `DELETE /api/workorders/{id}/` - 删除施工单
    - `POST /api/workorders/{id}/approve/` - 审核通过
    - `POST /api/workorders/{id}/reject/` - 审核拒绝

    ### 任务 (Tasks)
    - `GET /api/tasks/` - 获取任务列表
    - `GET /api/tasks/{id}/` - 获取任务详情
    - `POST /api/tasks/{id}/assign/` - 分配任务
    - `POST /api/tasks/{id}/claim/` - 认领任务
    - `POST /api/tasks/{id}/start/` - 开始任务
    - `POST /api/tasks/{id}/complete/` - 完成任务
    - `POST /api/tasks/{id}/cancel/` - 取消任务
    - `POST /api/tasks/bulk_assign/` - 批量分配
    - `POST /api/tasks/bulk_delete/` - 批量删除

    ### 通知 (Notifications)
    - `GET /api/notifications/` - 获取通知列表
    - `POST /api/notifications/{id}/mark_read/` - 标记已读
    - `POST /api/notifications/mark_all_read/` - 全部标记已读
    - `GET /api/notifications/unread_count/` - 未读数量

    ### 统计 (Statistics)
    - `GET /api/statistics/task_summary/` - 任务汇总统计
    - `GET /api/statistics/department_workload/` - 部门工作负载
    - `GET /api/statistics/collaboration/` - 协作统计

    ### 系统配置
    - `GET /api/departments/` - 部门列表
    - `GET /api/processes/` - 工序列表
    - `GET /api/task-assignment-rules/` - 任务分派规则
    - `POST /api/task-assignment-rules/` - 创建分派规则

    ## 请求/响应格式

    ### 分页响应
    列表接口返回分页数据：
    ```json
    {
      "count": 100,
      "next": "http://api.example.com/api/tasks/?page=2",
      "previous": null,
      "results": [...]
    }
    ```

    ### 错误响应
    ```json
    {
      "error": "错误类型",
      "message": "详细错误信息",
      "details": {}
    }
    ```

    ## 使用示例

    ### 创建施工单
    ```bash
    curl -X POST http://localhost:8000/api/workorders/ \\
      -H "Authorization: Token your_token" \\
      -H "Content-Type: application/json" \\
      -d '{
        "customer": 1,
        "production_quantity": 1000,
        "delivery_date": "2026-12-31",
        "priority": "normal",
        "processes": [
          {"process": 1, "sequence": 10},
          {"process": 2, "sequence": 20}
        ]
      }'
    ```

    ### 分配任务
    ```bash
    curl -X POST http://localhost:8000/api/tasks/123/assign/ \\
      -H "Authorization: Token your_token" \\
      -H "Content-Type: application/json" \\
      -d '{"operator_id": 45, "notes": "紧急任务"}'
    ```

    ### 查询任务
    ```bash
    curl -X GET "http://localhost:8000/api/tasks/?status=pending&assigned_department=1" \\
      -H "Authorization: Token your_token"
    ```

    ## 客户端 SDK 生成

    使用 OpenAPI schema 可以生成各种语言的客户端 SDK：

    ```bash
    # 使用 openapi-generator
    openapi-generator-cli generate -i openapi.yaml -g javascript -o ./client-js
    openapi-generator-cli generate -i openapi.yaml -g python -o ./client-python
    ```

    ## 版本历史

    - **v1.0.0** (2026-02-02) - 初始版本，包含核心任务管理功能
    ```

    This creates a comprehensive API reference guide with examples and authentication details.
  </action>
  <verify>
    ls -la backend/docs/api/ && cat backend/docs/api/README.md | head -50
  </verify>
  <done>
    OpenAPI schema files generated in JSON and YAML formats with comprehensive README
  </done>
</task>

<task type="auto">
  <name>Create comprehensive user manual in Chinese</name>
  <files>docs/USER_MANUAL.md</files>
  <action>
    Create docs/USER_MANUAL.md with complete user documentation:

    ```markdown
    # 印刷施工单跟踪系统 - 用户手册

    ## 目录

    1. [系统概述](#系统概述)
    2. [角色与权限](#角色与权限)
    3. [快速开始](#快速开始)
    4. [施工单管理](#施工单管理)
    5. [任务管理](#任务管理)
    6. [部门主管功能](#部门主管功能)
    7. [操作员功能](#操作员功能)
    8. [实时通知](#实时通知)
    9. [数据统计](#数据统计)
    10. [常见问题](#常见问题)

    ## 系统概述

    印刷施工单跟踪系统是一个用于管理印刷施工单和生产任务的综合系统。系统实现了"创建即分派，审核即开工"的理念，施工单一经创建即可预览所有任务，审核通过后任务立即可用。

    **核心功能**：
    - 施工单的创建、编辑和审核
    - 任务的自动生成和智能分派
    - 部门主管的任务分配
    - 操作员的任务认领和进度更新
    - 实时的任务通知
    - 完整的数据统计和分析

    ## 角色与权限

    ### 系统

    系统管理员拥有所有权限，负责用户管理和系统配置。

    ### 部门主管

    部门主管负责：
    - 审核施工单
    - 分配任务给操作员
    - 查看部门任务统计
    - 配置工序分派规则

    ### 操作员

    操作员负责：
    - 查看分配的任务
    - 认领未分配的任务
    - 更新任务进度
    - 完成任务

    ### 制单员/销售

    制单员和销售人员负责：
    - 创建施工单
    - 编辑草稿状态的施工单
    - 查看自己创建的施工单

    ## 快速开始

    ### 登录系统

    1. 打开浏览器，访问系统地址
    2. 输入用户名和密码
    3. 点击"登录"按钮

    ### 首页导航

    登录后，首页显示：
    - 顶部导航栏：包含主要功能菜单
    - 通知铃铛：显示未读通知数量
    - 用户菜单：个人信息和退出登录

    左侧菜单包含：
    - 施工单管理
    - 任务中心
    - 部门主管（仅主管可见）
    - 操作员中心（仅操作员可见）
    - 数据统计
    - 系统设置

    ## 施工单管理

    ### 创建施工单

    1. 点击左侧菜单"施工单管理"
    2. 点击"新建施工单"按钮
    3. 填写施工单基本信息：
       - 客户：从下拉列表选择客户
       - 生产数量：输入生产数量
       - 交货日期：选择交货日期
       - 优先级：选择紧急程度（低/普通/高/紧急）
       - 备注：输入可选的备注信息
    4. 添加产品：
       - 点击"添加产品"
       - 选择产品和数量
    5. 选择工序：
       - 从可用工序列表中选择需要的工序
       - 工序会自动排序
    6. 确认后，系统自动为每个工序生成草稿任务
    7. 点击"提交"保存施工单

    ### 编辑施工单

    **注意**：只有"草稿"或"已提交"状态的施工单可以编辑。

    1. 在施工单列表中找到要编辑的施工单
    2. 点击"编辑"按钮
    3. 修改需要更改的内容
    4. 点击"保存"提交修改

    **编辑工序时的注意事项**：
    - 如果工序发生变化，系统会提示是否同步任务
    - 选择"是"会添加新工序的任务，删除已移除工序的任务
    - 草稿任务可以手动删除或批量编辑

    ### 审核施工单

    部门主管可以审核施工单：

    1. 打开施工单详情
    2. 点击"审核通过"按钮
    3. 系统执行以下操作：
       - 所有草稿任务转换为正式任务
       - 根据分派规则自动分配到部门
       - 施工单状态变更为"已审核"

    如果需要拒绝：
    1. 点击"审核拒绝"
    2. 输入拒绝原因
    3. 所有草稿任务将被删除
    4. 施工单状态变更为"已拒绝"

    ## 任务管理

    ### 任务列表

    任务列表显示所有你有权限查看的任务：

    **筛选功能**：
    - 按部门筛选
    - 按状态筛选（草稿/待分配/进行中/已完成/已取消）
    - 按操作员筛选
    - 按优先级筛选
    - 搜索关键词

    **任务状态说明**：
    - 草稿（灰色）：施工单未审核时的临时状态
    - 待分配（蓝色）：已分配到部门，等待分配操作员
    - 进行中（黄色）：操作员正在处理
    - 已完成（绿色）：任务已完成

    ### 查看任务详情

    1. 点击任务列表中的任务
    2. 详情页显示：
       - 关联的施工单信息
       - 工序信息
       - 分配的部门和操作员
       - 任务数量和完成进度
       - 任务日志

    ### 批量操作

    选中多个任务后，可以执行：
    - 批量分配（主管权限）
    - 批量删除（仅草稿任务）
    - 批量取消

    ## 部门主管功能

    ### 主管仪表板

    点击"部门主管"菜单进入主管仪表板，显示：

    **部门概览**：
    - 总任务数
    - 待分配任务数
    - 进行中任务数
    - 已完成任务数
    - 完成率

    **操作员负载**：
    - 每个操作员的任务数量
    - 各操作员的完成率
    - 点击可查看该操作员的详细任务

    ### 任务分配

    方式一：从任务列表分配
    1. 在任务列表中找到待分配任务
    2. 点击"分配"按钮
    3. 选择操作员
    4. 可选：输入分配备注
    5. 确认分配

    方式二：拖拽分配（推荐）
    1. 在主管仪表板中
    2. 从左侧"未分配"列拖动任务
    3. 放到右侧对应的操作员列
    4. 系统自动完成分配

    **分配规则**：
    - 只能分配本部门的任务
    - 操作员最多同时持有10个任务
    - 已取消的任务不能重新分配

    ### 配置分派规则

    1. 进入"系统设置" -> "任务分派规则"
    2. 选择要配置的工序
    3. 设置部门优先级：
       - 使用拖拽调整优先级顺序
       - 数字越小优先级越高
       - 可以禁用某个部门的分派
    4. 选择分派策略：
       - 优先级优先：始终选择最高优先级部门
       - 负载均衡：在相同优先级中选择负载最低的部门
    5. 保存配置

    ### 查看部门统计

    进入"数据统计"页面查看：
    - 任务完成趋势图
    - 部门任务分布
    - 操作员绩效排名
    - 平均完成时间

    ## 操作员功能

    ### 操作员中心

    点击"操作员中心"进入专属界面：

    **我的任务**标签页：
    - 显示分配给你的所有任务
    - 按状态分组（全部/待分配/进行中/已完成）
    - 显示任务进度和优先级

    **可认领任务**标签页：
    - 显示本部门未分配的任务
    - 一键认领功能

    ### 认领任务

    1. 在"可认领任务"列表中找到任务
    2. 点击"认领"按钮
    3. 任务自动分配给你

    **注意**：如果多个操作员同时认领同一任务，只有一个会成功，其他会收到冲突提示。

    ### 更新任务进度

    1. 点击任务卡片
    2. 选择"更新进度"
    3. 输入已完成数量
    4. 可选：输入次品数量
    5. 系统自动计算进度百分比

    ### 完成任务

    1. 点击任务卡片
    2. 选择"完成任务"
    3. 输入完成数量
    4. 输入次品数量（如有）
    5. 可选：输入完成说明
    6. 确认完成

    完成后：
    - 任务状态变为"已完成"
    - 主管会收到完成通知
    - 统计数据自动更新

    ## 实时通知

    ### 接收通知

    系统会在以下事件发生时发送通知：
    - 任务被分配给你
    - 任务被完成
    - 施工单被审核

    通知方式：
    - 浏览器通知（需授权）
    - 右上角通知铃铛
    - 通知中心页面

    ### 查看通知历史

    1. 点击通知铃铛图标
    2. 查看最近的通知
    3. 点击"查看全部"进入通知中心

    通知中心显示最近30天的所有通知。

    ### 通知设置

    进入"个人设置"可以配置：
    - 是否启用浏览器通知
    - 通知提示音
    - 通知显示时长

    ## 数据统计

    ### 任务统计

    进入"数据统计"页面查看：

    **总体统计**：
    - 今日完成任务数
    - 本周完成任务数
    - 当前待处理任务数
    - 平均完成时间

    **趋势图表**：
    - 任务完成趋势（按天/周/月）
    - 部门任务分布
    - 操作员绩效对比

    ### 导出数据

    系统支持导出以下数据：
    - 任务列表（Excel格式）
    - 完成统计（CSV格式）
    - 部门报表（PDF格式）

    点击"导出"按钮选择格式和范围。

    ## 常见问题

    ### Q: 为什么我的施工单不能编辑？

    A: 只有"草稿"和"已提交"状态的施工单可以编辑。"已审核"的施工单不能编辑，这是为了保证生产数据的稳定性。

    ### Q: 草稿任务是什么？

    A: 草稿任务是创建施工单时自动生成的临时任务。它们在施工单审核通过后转换为正式任务。草稿任务可以编辑和删除。

    ### Q: 如何更改任务的操作员？

    A: 只有部门主管可以重新分配任务。主管可以在任务列表或主管仪表板中进行更改。操作员不能自行转交任务。

    ### Q: 任务认领失败怎么办？

    A: 如果认领失败，可能是因为：
    - 任务已被其他人认领
    - 你不在该任务的部门中
    - 你已达到最大任务数量限制

    刷新页面后重试，或联系部门主管。

    ### Q: 为什么我看不到某些任务？

    A: 任务可见性基于你的角色和部门：
    - 主管可以看到本部门的所有任务
    - 操作员只能看到分配给自己的任务和本部门的可认领任务
    - 制单员可以看到自己创建的施工单的任务

    ### Q: 如何配置部门优先级？

    A: 只有系统管理员和部门主管可以配置分派规则。进入"系统设置" -> "任务分派规则"进行配置。

    ### Q: 通知保留多久？

    A: 通知保留30天。30天前的通知不会显示在列表中，但管理员可以在后台查看历史数据。

    ### Q: 如何删除施工单？

    A: 只有"草稿"状态的施工单可以删除。已提交的施工单需要先被拒绝后才能删除。这是为了防止误删除影响生产。

    ## 技术支持

    如果遇到问题或需要帮助，请联系：
    - 系统管理员
    - IT 部门
    - 或查看在线帮助文档

    ## 更新日志

    - **v1.0.0** (2026-02-02) - 初始版本发布
    ```

    This provides a comprehensive user guide in Chinese covering all system features.
  </action>
  <verify>
    wc -l docs/USER_MANUAL.md && grep "^##" docs/USER_MANUAL.md | head -20
  </verify>
  <done>
    User manual created with 10+ sections covering all system functionality in Chinese
  </done>
</task>

<task type="auto">
  <name>Create deployment guide with checklist</name>
  <files>docs/DEPLOYMENT.md</files>
  <action>
    Update docs/DEPLOYMENT.md with comprehensive deployment guide:

    First, read the existing file and then update it. If it doesn't exist or needs significant update, create:

    ```markdown
    # 印刷施工单跟踪系统 - 部署指南

    ## 目录

    1. [系统要求](#系统要求)
    2. [部署准备](#部署准备)
    3. [后端部署](#后端部署)
    4. [前端部署](#前端部署)
    5. [Nginx 配置](#nginx-配置)
    6. [监控配置](#监控配置)
    7. [备份配置](#备份配置)
    8. [部署检查清单](#部署检查清单)

    ## 系统要求

    ### 硬件要求

    **最低配置**：
    - CPU: 2 核
    - 内存: 4GB
    - 硬盘: 20GB

    **推荐配置**：
    - CPU: 4 核或更多
    - 内存: 8GB 或更多
    - 硬盘: 50GB 或更多（SSD 推荐）

    ### 软件要求

    - **操作系统**: Ubuntu 20.04+ / CentOS 8+ / Debian 11+
    - **Python**: 3.11+
    - **Node.js**: 18.x+
    - **数据库**: PostgreSQL 14+ (推荐) 或 SQLite 3+
    - **缓存**: Redis 7+
    - **Web 服务器**: Nginx 1.20+
    - **进程管理**: systemd

    ## 部署准备

    ### 1. 创建部署用户

    ```bash
    sudo useradd -m -s /bin/bash workorder
    sudo passwd workorder
    sudo usermod -aG sudo workorder
    ```

    ### 2. 安装系统依赖

    **Ubuntu/Debian**:
    ```bash
    sudo apt update
    sudo apt install -y python3.11 python3.11-venv python3-pip nodejs npm postgresql redis-server nginx
    ```

    **CentOS/RHEL**:
    ```bash
    sudo yum install -y python3.11 python3.11-venv nodejs npm postgresql-server redis nginx
    ```

    ### 3. 创建项目目录

    ```bash
    sudo mkdir -p /opt/workorder
    sudo chown workorder:workorder /opt/workorder
    cd /opt/workorder
    ```

    ### 4. 克隆代码

    ```bash
    git clone <your-repo-url> .
    ```

    ## 后端部署

    ### 1. 创建 Python 虚拟环境

    ```bash
    cd backend
    python3.11 -m venv venv
    source venv/bin/activate
    ```

    ### 2. 安装依赖

    ```bash
    pip install --upgrade pip
    pip install -r requirements.txt
    pip install gunicorn daphne
    ```

    ### 3. 配置环境变量

    创建 `.env` 文件：
    ```bash
    cp .env.example .env
    nano .env
    ```

    配置以下环境变量：
    ```bash
    # Django 密钥（必须修改）
    SECRET_KEY=your-very-secret-key-change-this-in-production

    # 调试模式（生产环境必须为 False）
    DEBUG=False

    # 允许的主机
    ALLOWED_HOSTS=your-domain.com,www.your-domain.com

    # 数据库配置
    POSTGRES_DB=workorder
    POSTGRES_USER=workorder
    POSTGRES_PASSWORD=your-secure-password
    POSTGRES_HOST=localhost
    POSTGRES_PORT=5432

    # Redis 配置
    REDIS_URL=redis://localhost:6379/0

    # 邮件配置（可选）
    EMAIL_HOST=smtp.example.com
    EMAIL_PORT=587
    EMAIL_HOST_USER=noreply@example.com
    EMAIL_HOST_PASSWORD=your-email-password
    ADMIN_EMAIL=admin@example.com
    ```

    ### 4. 配置 PostgreSQL 数据库

    ```bash
    sudo -u postgres psql
    ```

    ```sql
    CREATE DATABASE workorder;
    CREATE USER workorder WITH PASSWORD 'your-secure-password';
    GRANT ALL PRIVILEGES ON DATABASE workorder TO workorder;
    \\q
    ```

    ### 5. 运行数据库迁移

    ```bash
    python manage.py migrate
    ```

    ### 6. 创建超级用户

    ```bash
    python manage.py createsuperuser
    ```

    ### 7. 收集静态文件

    ```bash
    python manage.py collectstatic --noinput
    ```

    ### 8. 配置 Gunicorn

    创建 `backend/deployment/gunicorn.conf.py`:
    ```python
    import multiprocessing

    bind = "127.0.0.1:8000"
    backlog = 2048

    workers = (2 * multiprocessing.cpu_count()) + 1
    worker_class = "sync"
    worker_connections = 1000
    max_requests = 1000
    max_requests_jitter = 100
    timeout = 30
    keepalive = 2

    proc_name = "workorder_backend"

    accesslog = "/var/log/gunicorn/access.log"
    errorlog = "/var/log/gunicorn/error.log"
    loglevel = "info"

    daemon = False
    pidfile = "/var/run/gunicorn/gunicorn.pid"
    user = "workorder"
    group = "workorder"
    umask = 007
    ```

    ### 9. 配置 Daphne (WebSocket 服务)

    创建 `backend/deployment/systemd/daphne.service`:
    ```ini
    [Unit]
    Description=Workorder Daphne WebSocket Daemon
    After=network.target gunicorn.service

    [Service]
    Type=notify
    User=workorder
    Group=workorder
    RuntimeDirectory=daphne
    WorkingDirectory=/opt/workorder/backend
    Environment="PATH=/opt/workorder/backend/venv/bin"
    ExecStart=/opt/workorder/backend/venv/bin/daphne -b 127.0.0.1 -p 8001 config.asgi:application
    ExecReload=/bin/kill -s HUP $MAINPID
    KillMode=mixed
    TimeoutStopSec=30
    PrivateTmp=true
    Restart=always
    RestartSec=5

    [Install]
    WantedBy=multi-user.target
    ```

    ### 10. 配置 systemd 服务

    创建 `/etc/systemd/system/workorder.service`:
    ```ini
    [Unit]
    Description=Workorder Gunicorn Daemon
    After=network.target postgresql.service

    [Service]
    Type=notify
    User=workorder
    Group=workorder
    RuntimeDirectory=gunicorn
    WorkingDirectory=/opt/workorder/backend
    Environment="PATH=/opt/workorder/backend/venv/bin"
    EnvironmentFile=/opt/workorder/backend/.env
    ExecStart=/opt/workorder/backend/venv/bin/gunicorn --config deployment/gunicorn.conf.py config.wsgi:application
    ExecReload=/bin/kill -s HUP $MAINPID
    KillMode=mixed
    TimeoutStopSec=30
    PrivateTmp=true
    Restart=always
    RestartSec=5

    [Install]
    WantedBy=multi-user.target
    ```

    启动服务：
    ```bash
    sudo systemctl daemon-reload
    sudo systemctl enable workorder daphne
    sudo systemctl start workorder daphne
    sudo systemctl status workorder daphne
    ```

    ## 前端部署

    ### 1. 安装依赖

    ```bash
    cd ../frontend
    npm install
    ```

    ### 2. 配置 API 地址

    修改 `frontend/.env.production`:
    ```bash
    VUE_APP_API_URL=https://your-domain.com/api
    VUE_APP_WS_URL=wss://your-domain.com/ws
    ```

    ### 3. 构建生产版本

    ```bash
    npm run build
    ```

    ### 4. 部署静态文件

    ```bash
    sudo mkdir -p /var/www/workorder
    sudo cp -r dist/* /var/www/workorder/
    sudo chown -R www-data:www-data /var/www/workorder
    ```

    ## Nginx 配置

    创建 `/etc/nginx/sites-available/workorder`:
    ```nginx
    upstream django_backend {
        least_conn;
        server 127.0.0.1:8000 max_fails=3 fail_timeout=30s;
    }

    upstream daphne_websocket {
        server 127.0.0.1:8001;
    }

    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;

    server {
        listen 80;
        server_name your-domain.com;
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name your-domain.com;

        # SSL 配置（使用 Let's Encrypt）
        ssl_certificate /etc/letsencrypt/live/your-domain.com/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/your-domain.com/privkey.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';
        ssl_prefer_server_ciphers on;

        # 安全头
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;

        client_max_body_size 100M;

        # 静态文件
        location /static/ {
            alias /opt/workorder/backend/staticfiles/;
            expires 30d;
            add_header Cache-Control "public, immutable";
        }

        # 媒体文件
        location /media/ {
            alias /opt/workorder/backend/media/;
            expires 7d;
        }

        # API 端点
        location /api/ {
            limit_req zone=api_limit burst=20 nodelay;

            proxy_pass http://django_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }

        # WebSocket
        location /ws/ {
            proxy_pass http://daphne_websocket;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;

            proxy_connect_timeout 7d;
            proxy_send_timeout 7d;
            proxy_read_timeout 7d;
        }

        # 前端
        location / {
            root /var/www/workorder;
            try_files $uri $uri/ /index.html;
        }
    }
    ```

    启用配置：
    ```bash
    sudo ln -s /etc/nginx/sites-available/workorder /etc/nginx/sites-enabled/
    sudo nginx -t
    sudo systemctl reload nginx
    ```

    ## 监控配置

    ### 使用 Prometheus + Grafana

    1. 安装 Prometheus:
    ```bash
    sudo apt install prometheus
    ```

    2. 配置 Prometheus (`/etc/prometheus/prometheus.yml`):
    ```yaml
    global:
      scrape_interval: 15s

    scrape_configs:
      - job_name: 'django'
        static_configs:
          - targets: ['localhost:8000']
        metrics_path: '/metrics/'
    ```

    3. 安装 Grafana:
    ```bash
    sudo apt install grafana
    sudo systemctl start grafana
    ```

    4. 在 Grafana 中添加 Prometheus 数据源并导入仪表板。

    ### 日志查看

    ```bash
    # Django 日志
    sudo journalctl -u workorder -f

    # Daphne 日志
    sudo journalctl -u daphne -f

    # Nginx 日志
    sudo tail -f /var/log/nginx/access.log
    sudo tail -f /var/log/nginx/error.log
    ```

    ## 备份配置

    ### 数据库备份

    创建备份脚本 `/opt/workorder/backend/deployment/scripts/backup.sh`:
    ```bash
    #!/bin/bash
    set -e

    BACKUP_DIR="/var/backups/workorder"
    DATE=$(date +%Y%m%d_%H%M%S)
    mkdir -p $BACKUP_DIR

    # 数据库备份
    PGPASSWORD="your-password" pg_dump -U workorder -h localhost workorder | gzip > $BACKUP_DIR/db_$DATE.sql.gz

    # 媒体文件备份
    tar -czf $BACKUP_DIR/media_$DATE.tar.gz /opt/workorder/backend/media/

    # 删除30天前的备份
    find $BACKUP_DIR -name "*.gz" -mtime +30 -delete

    echo "Backup completed: $DATE"
    ```

    配置定时任务：
    ```bash
    sudo crontab -e
    ```

    添加：
    ```
    0 2 * * * /opt/workorder/backend/deployment/scripts/backup.sh >> /var/log/backup.log 2>&1
    ```

    ### 恢复备份

    ```bash
    # 停止服务
    sudo systemctl stop workorder

    # 恢复数据库
    gunzip -c /var/backups/workorder/db_YYYYMMDD_HHMMSS.sql.gz | psql -U workorder -h localhost workorder

    # 恢复媒体文件
    tar -xzf /var/backups/workorder/media_YYYYMMDD_HHMMSS.tar.gz -C /

    # 重启服务
    sudo systemctl start workorder
    ```

    ## 部署检查清单

    ### 部署前

    - [ ] 确认服务器硬件配置满足要求
    - [ ] 确认操作系统版本和依赖软件已安装
    - [ ] 准备好域名和 SSL 证书
    - [ ] 创建部署用户并配置 sudo 权限
    - [ ] 准备好环境变量配置

    ### 数据库

    - [ ] 创建 PostgreSQL 数据库和用户
    - [ ] 配置数据库连接权限
    - [ ] 运行数据库迁移
    - [ ] 创建初始超级用户
    - [ ] 加载初始数据（工序、部门等）

    ### 后端

    - [ ] 创建 Python 虚拟环境
    - [ ] 安装所有依赖包
    - [ ] 配置 .env 文件
    - [ ] 收集静态文件
    - [ ] 配置 Gunicorn
    - [ ] 配置 Daphne (WebSocket)
    - [ ] 配置 systemd 服务
    - [ ] 启动并验证服务状态

    ### 前端

    - [ ] 安装 npm 依赖
    - [ ] 配置生产环境 API 地址
    - [ ] 构建生产版本
    - [ ] 部署到 Web 服务器目录
    - [ ] 验证前端可访问

    ### Nginx

    - [ ] 配置 SSL 证书
    - [ ] 配置反向代理
    - [ ] 配置 WebSocket 代理
    - [ ] 配置静态文件服务
    - [ ] 测试配置并重载

    ### 监控和备份

    - [ ] 配置 Prometheus 监控
    - [ ] 配置 Grafana 仪表板
    - [ ] 设置日志轮转
    - [ ] 配置数据库自动备份
    - [ ] 测试备份恢复流程

    ### 安全检查

    - [ ] DEBUG=False
    - [ ] SECRET_KEY 已修改
    - [ ] ALLOWED_HOSTS 正确配置
    - [ ] 数据库密码安全
    - [ ] HTTPS 已启用
    - [ ] 防火墙规则已配置
    - [ ] 日志记录已启用

    ### 功能验证

    - [ ] 用户可以登录
    - [ ] 可以创建施工单
    - [ ] 任务自动生成
    - [ ] 审核流程正常
    - [ ] 任务分配功能正常
    - [ ] WebSocket 通知正常
    - [ ] 统计数据正确显示

    ### 性能验证

    - [ ] 页面加载时间 < 2秒
    - [ ] API 响应时间 < 500ms
    - [ ] 并发用户测试通过
    - [ ] 数据库查询优化生效
    - [ ] 缓存正常工作

    ## 故障排查

    ### 服务无法启动

    查看日志：
    ```bash
    sudo journalctl -u workorder -n 50
    sudo journalctl -u daphne -n 50
    ```

    常见问题：
    - 端口被占用：修改 Gunicorn/Daphne 端口
    - 数据库连接失败：检查数据库配置和连接
    - 权限问题：检查文件和目录权限

    ### WebSocket 连接失败

    - 确认 Daphne 服务运行正常
    - 检查 Nginx WebSocket 配置
    - 确认 Redis 服务运行正常

    ### 性能问题

    - 检查数据库连接数
    - 查看慢查询日志
    - 验证 Redis 缓存工作状态
    - 检查 Gunicorn worker 数量

    ## 更新部署

    ### 后端更新

    ```bash
    cd /opt/workorder/backend
    source venv/bin/activate
    git pull
    pip install -r requirements.txt
    python manage.py migrate
    python manage.py collectstatic --noinput
    sudo systemctl restart workorder
    ```

    ### 前端更新

    ```bash
    cd /opt/workorder/frontend
    git pull
    npm install
    npm run build
    sudo cp -r dist/* /var/www/workorder/
    ```

    ## 联系支持

    如需技术支持，请联系：
    - 邮箱: support@example.com
    - 文档: https://docs.example.com
    ```

    This provides a complete deployment guide with checklist.
  </action>
  <verify>
    wc -l docs/DEPLOYMENT.md && grep "^- \[x\]\|^- \[ \]" docs/DEPLOYMENT.md | wc -l
  </verify>
  <done>
    Deployment guide created with comprehensive checklist covering all deployment aspects
  </done>
</task>

</tasks>

<verification>
After completing all tasks, verify:

1. Swagger UI is accessible at http://localhost:8000/api/docs/
2. OpenAPI schema is generated correctly (JSON and YAML)
3. All task-related endpoints have Chinese descriptions
4. User manual covers all system features in Chinese
5. Deployment guide includes complete checklist
6. API docs are in sync with code (auto-generated)
7. Documentation is properly formatted and readable
</verification>

<success_criteria>
- drf-spectacular configured and generating OpenAPI 3.0 schema
- Swagger UI accessible with interactive API documentation
- All task endpoints documented with @extend_schema decorators
- User manual created in Chinese with 10+ sections
- Deployment guide includes pre-flight and post-deployment checklists
- Schema files exported in JSON and YAML formats
- API documentation README includes examples and authentication details
</success_criteria>

<output>
After completion, create `.planning/phases/10-production-hardening/10-02-SUMMARY.md` with:
- Number of documented API endpoints
- Documentation files created
- Links to Swagger UI and schema files
- Any documentation improvements made
</output>
