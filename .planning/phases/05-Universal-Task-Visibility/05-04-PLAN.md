---
phase: 05-Universal-Task-Visibility
plan: 04
type: execute
wave: 2
depends_on: [05-01]
files_modified:
  - backend/workorder/views/work_order_tasks/task_export.py
  - backend/workorder/views/work_order_tasks/task_main.py
  - backend/workorder/views/work_order_tasks/__init__.py
  - frontend/src/api/modules/workorder-task.js
  - frontend/src/views/task/TaskList.vue
autonomous: true

must_haves:
  truths:
    - "User can export filtered task list to Excel"
    - "Exported file includes all visible columns (ID, work order, content, department, operator, status, etc.)"
    - "Export respects current filters (status, department, search, etc.)"
    - "Export includes batch selection if tasks are selected"
    - "Export filename includes timestamp"
  artifacts:
    - path: "backend/workorder/views/work_order_tasks/task_export.py"
      provides: "TaskExportMixin with export endpoint"
      contains: "export_excel method"
    - path: "frontend/src/api/modules/workorder-task.js"
      provides: "exportExcel API method"
      exports: ["exportExcel"]
    - path: "frontend/src/views/task/TaskList.vue"
      provides: "Export button with filtered data support"
      contains: "handleExport method"
  key_links:
    - from: "frontend/src/views/task/TaskList.vue"
      to: "frontend/src/api/modules/workorder-task.js"
      via: "exportExcel method call"
      pattern: "exportExcel"
    - from: "frontend/src/api/modules/workorder-task.js"
      to: "backend/workorder/views/work_order_tasks/task_export.py"
      via: "export endpoint"
      pattern: "export/"
---

<objective>
Create TaskExportMixin for backend Excel export and integrate frontend export functionality. Export should respect filters and use openpyxl for server-side Excel generation (more reliable than client-side for large datasets).

Purpose: Implement PAGE-05 requirement for task list export functionality.

Output: TaskExportMixin with export endpoint, frontend API integration, and export button functionality.
</objective>

<execution_context>
@/home/chenjiaxing/.claude/get-shit-done/workflows/execute-plan.md
@/home/chenjiaxing/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-Task-Assignment-Core/04-01-SUMMARY.md
@.planning/phases/05-Universal-Task-Visibility/05-RESEARCH.md
@.planning/phases/05-Universal-Task-Visibility/05-01-PLAN.md

# Key existing files
@backend/workorder/views/work_order_tasks/task_main.py
@frontend/src/views/task/TaskList.vue
@frontend/src/api/modules/workorder-task.js
@frontend/src/mixins/exportMixin.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TaskExportMixin with server-side Excel export</name>
  <files>backend/workorder/views/work_order_tasks/task_export.py</files>
  <action>
Create new file `backend/workorder/views/work_order_tasks/task_export.py`:

```python
"""
施工单任务导出 Mixin
提供Excel导出功能
"""

from rest_framework import status
from rest_framework.decorators import action
from rest_framework.response import Response
from django.http import HttpResponse
from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
from datetime import datetime
import logging

from workorder.models.core import WorkOrderTask

logger = logging.getLogger(__name__)


class TaskExportMixin:
    """
    任务导出 Mixin

    提供Excel导出功能，支持筛选条件导出
    """

    @action(detail=False, methods=['post'], url_path='export')
    def export_excel(self, request):
        """
        导出任务列表到Excel

        请求参数：
        - filters: 筛选条件（可选，与list接口相同）
        - task_ids: 指定导出的任务ID列表（可选，优先级高于filters）
        - columns: 指定导出的列（可选，默认导出所有列）

        返回：Excel文件流
        """
        from openpyxl.utils import get_column_letter

        # 获取导出参数
        task_ids = request.data.get('task_ids', [])
        filters = request.data.get('filters', {})
        columns = request.data.get('columns', [
            'id', 'work_order_number', 'process_name', 'task_type',
            'work_content', 'assigned_department', 'assigned_operator',
            'production_quantity', 'quantity_completed', 'progress',
            'priority', 'status', 'created_at', 'updated_at'
        ])

        # 构建查询集
        if task_ids:
            # 优先使用指定任务ID
            queryset = self.get_queryset().filter(id__in=task_ids)
        else:
            # 使用筛选条件
            queryset = self.filter_queryset(self.get_queryset())

        # 限制导出数量（防止导出过多数据）
        max_export = 10000
        if queryset.count() > max_export:
            return Response(
                {'error': f'导出数据量过大（{queryset.count()}条），最多支持导出{max_export}条'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # 创建工作簿
        wb = Workbook()
        ws = wb.active
        ws.title = '任务列表'

        # 定义列标题和宽度
        column_config = {
            'id': {'title': 'ID', 'width': 10},
            'work_order_number': {'title': '施工单号', 'width': 18},
            'process_name': {'title': '工序', 'width': 15},
            'task_type': {'title': '任务类型', 'width': 12},
            'work_content': {'title': '任务内容', 'width': 30},
            'assigned_department': {'title': '分派部门', 'width': 15},
            'assigned_operator': {'title': '分派操作员', 'width': 12},
            'production_quantity': {'title': '生产数量', 'width': 12},
            'quantity_completed': {'title': '完成数量', 'width': 12},
            'quantity_defective': {'title': '不良品数量', 'width': 12},
            'progress': {'title': '进度(%)', 'width': 10},
            'priority': {'title': '优先级', 'width': 10},
            'status': {'title': '状态', 'width': 12},
            'created_at': {'title': '创建时间', 'width': 18},
            'updated_at': {'title': '更新时间', 'width': 18},
        }

        # 设置列标题
        header_style = Font(bold=True, color='FFFFFF')
        header_fill = PatternFill(start_color='4472C4', end_color='4472C4', fill_type='solid')
        header_alignment = Alignment(horizontal='center', vertical='center')
        border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )

        for col_idx, col_key in enumerate(columns, 1):
            col_config = column_config.get(col_key, {'title': col_key, 'width': 15})
            cell = ws.cell(row=1, column=col_idx)
            cell.value = col_config['title']
            cell.font = header_style
            cell.fill = header_fill
            cell.alignment = header_alignment
            cell.border = border
            ws.column_dimensions[get_column_letter(col_idx)].width = col_config['width']

        # 填充数据
        status_display_map = dict(WorkOrderTask.STATUS_CHOICES)
        task_type_display_map = dict(WorkOrderTask.TASK_TYPE_CHOICES)
        priority_display_map = dict(WorkOrderTask.PRIORITY_CHOICES)

        row_idx = 2
        for task in queryset:
            row_data = self._get_row_data(task, columns, status_display_map, task_type_display_map, priority_display_map)

            for col_idx, value in enumerate(row_data, 1):
                cell = ws.cell(row=row_idx, column=col_idx)
                cell.value = value
                cell.alignment = Alignment(vertical='center', wrap_text=True)
                cell.border = border

                # 状态列着色
                if columns[col_idx - 1] == 'status':
                    if task.status == 'completed':
                        cell.fill = PatternFill(start_color='C6EFCE', end_color='C6EFCE', fill_type='solid')
                    elif task.status == 'cancelled':
                        cell.fill = PatternFill(start_color='FFC7CE', end_color='FFC7CE', fill_type='solid')
                    elif task.status == 'draft':
                        cell.fill = PatternFill(start_color='E2EFDA', end_color='E2EFDA', fill_type='solid')

            row_idx += 1

        # 冻结首行
        ws.freeze_panes = 'A2'

        # 设置行高
        ws.row_dimensions[1].height = 25

        # 生成文件名
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f'任务列表_{timestamp}.xlsx'

        # 创建响应
        response = HttpResponse(
            content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        )
        response['Content-Disposition'] = f'attachment; filename="{filename}"'

        wb.save(response)

        return response

    def _get_row_data(self, task, columns, status_map, type_map, priority_map):
        """获取单行数据"""
        row = []

        for col_key in columns:
            value = ''
            if col_key == 'id':
                value = task.id
            elif col_key == 'work_order_number':
                value = getattr(task.work_order_process.work_order, 'order_number', '') if task.work_order_process and task.work_order_process.work_order else ''
            elif col_key == 'process_name':
                value = str(task.work_order_process.process) if task.work_order_process and task.work_order_process.process else ''
            elif col_key == 'task_type':
                value = type_map.get(task.task_type, task.task_type) if task.task_type else ''
            elif col_key == 'work_content':
                value = task.work_content or ''
            elif col_key == 'assigned_department':
                value = str(task.assigned_department) if task.assigned_department else ''
            elif col_key == 'assigned_operator':
                value = str(task.assigned_operator) if task.assigned_operator else ''
            elif col_key == 'production_quantity':
                value = task.production_quantity or 0
            elif col_key == 'quantity_completed':
                value = task.quantity_completed or 0
            elif col_key == 'quantity_defective':
                value = task.quantity_defective or 0
            elif col_key == 'progress':
                if task.production_quantity and task.production_quantity > 0:
                    value = round((task.quantity_completed or 0) / task.production_quantity * 100, 1)
                else:
                    value = 0
            elif col_key == 'priority':
                value = priority_map.get(task.priority, task.priority) if task.priority else ''
            elif col_key == 'status':
                value = status_map.get(task.status, task.status) if task.status else ''
            elif col_key == 'created_at':
                value = task.created_at.strftime('%Y-%m-%d %H:%M') if task.created_at else ''
            elif col_key == 'updated_at':
                value = task.updated_at.strftime('%Y-%m-%d %H:%M') if task.updated_at else ''

            row.append(value)

        return row
```

This mixin provides:
- Server-side Excel generation using openpyxl
- Support for filtered export or selected tasks export
- Column selection
- Styled headers and status-based cell coloring
- Row and column formatting
  </action>
  <verify>
- task_export.py exists at backend/workorder/views/work_order_tasks/
- TaskExportMixin class defined with export_excel method
- Method accepts task_ids, filters, columns parameters
- Excel styling includes headers, borders, status colors
- Returns Excel file as HTTP response
  </verify>
  <done>
TaskExportMixin created with server-side Excel export functionality.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate TaskExportMixin into BaseWorkOrderTaskViewSet</name>
  <files>backend/workorder/views/work_order_tasks/task_main.py, backend/workorder/views/work_order_tasks/__init__.py</files>
  <action>
1. Update backend/workorder/views/work_order_tasks/task_main.py:

Add import at top (around line 17):
```python
from .task_export import TaskExportMixin
```

Update the class definition to inherit from TaskExportMixin (around line 23):
```python
class BaseWorkOrderTaskViewSet(TaskExportMixin, viewsets.ModelViewSet):
```

2. Update backend/workorder/views/work_order_tasks/__init__.py to include TaskExportMixin in combined ViewSet:

Read the file and ensure TaskExportMixin is included in the mixin list for WorkOrderTaskViewSet.
The file should import TaskExportMixin and include it in the mixin composition.
  </action>
  <verify>
- TaskExportMixin imported in task_main.py
- BaseWorkOrderTaskViewSet inherits from TaskExportMixin
- __init__.py includes TaskExportMixin in combined ViewSet
- export_excel endpoint available at /api/workorder-tasks/export/
  </verify>
  <done>
BaseWorkOrderTaskViewSet now includes export_excel endpoint from TaskExportMixin.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add frontend API export method</name>
  <files>frontend/src/api/modules/workorder-task.js</files>
  <action>
Add exportExcel method to WorkOrderTaskAPI class:

```javascript
/**
 * 导出任务列表到Excel
 * @param {Object} options
 * @param {Array<number>} options.task_ids - 指定导出的任务ID列表（可选）
 * @param {Object} options.filters - 筛选条件（可选）
 * @param {Array<string>} options.columns - 指定导出的列（可选）
 * @returns {Promise} Blob响应
 */
exportExcel(options = {}) {
  return this.request({
    url: `${this.baseUrl}export/`,
    method: 'post',
    data: {
      task_ids: options.task_ids || [],
      filters: options.filters || {},
      columns: options.columns || [
        'id', 'work_order_number', 'process_name', 'task_type',
        'work_content', 'assigned_department', 'assigned_operator',
        'production_quantity', 'quantity_completed', 'progress',
        'priority', 'status', 'created_at', 'updated_at'
      ]
    },
    responseType: 'blob'  # Important for file download
  })
}
```

The key point is responseType: 'blob' to handle binary file response.
  </action>
  <verify>
- exportExcel method exists in WorkOrderTaskAPI
- Method accepts task_ids, filters, columns options
- Uses POST to export/ endpoint
- responseType: 'blob' for binary download
  </verify>
  <done>
Frontend API has exportExcel method with blob response type for file download.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update TaskList.vue handleExport to use backend export</name>
  <files>frontend/src/views/task/TaskList.vue</files>
  <action>
The existing handleExport method (around line 645) uses client-side export via exportMixin.
Replace it with backend export API call for better performance with large datasets:

```javascript
/**
 * 导出任务列表
 */
async handleExport() {
  try {
    this.exporting = true

    // 如果有选中任务，只导出选中的
    const taskIds = this.selectedTasks.length > 0
      ? this.selectedTasks.map(t => t.id)
      : []

    // 调用后端导出API
    const response = await this.apiService.exportExcel({
      task_ids: taskIds,
      columns: [
        'id', 'work_order_number', 'process_name', 'task_type',
        'work_content', 'assigned_department', 'assigned_operator',
        'production_quantity', 'quantity_completed', 'progress',
        'priority', 'status', 'created_at', 'updated_at'
      ]
    })

    // 从响应中获取文件名
    const contentDisposition = response.headers['content-disposition']
    let filename = '任务列表.xlsx'
    if (contentDisposition) {
      const filenameMatch = contentDisposition.match(/filename="(.+)"/)
      if (filenameMatch) {
        filename = decodeURIComponent(filenameMatch[1])
      }
    }

    // 创建下载链接
    const blob = new Blob([response], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    })
    const url = window.URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = url
    link.download = filename
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    window.URL.revokeObjectURL(url)

    ErrorHandler.showSuccess('导出成功')
  } catch (error) {
    ErrorHandler.showMessage(error, '导出任务')
  } finally {
    this.exporting = false
  }
}
```

This implementation:
- Uses backend API for server-side Excel generation
- Exports selected tasks if any, otherwise uses current filters
- Handles blob response correctly
- Extracts filename from Content-Disposition header
- Creates download link programmatically
- Cleans up URL object after download
  </action>
  <verify>
- handleExport method calls apiService.exportExcel
- Passes selected task IDs if tasks selected
- Handles blob response type
- Creates download link and triggers download
- Error handling with ErrorHandler
- Filename extracted from Content-Disposition header
  </verify>
  <done>
TaskList.vue now uses backend export API for efficient server-side Excel generation.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Test export with filters:
   - Apply filters (status=pending, department=1)
   - Click "导出Excel" button
   - Verify download starts
   - Open Excel file and verify filtered data

2. Test export with selected tasks:
   - Select multiple tasks
   - Click "导出Excel" button
   - Verify only selected tasks exported
   - Open Excel file and verify correct tasks

3. Test export without selection/filters:
   - Clear all filters
   - Ensure no tasks selected
   - Click "导出Excel" button
   - Verify all accessible tasks exported

4. Verify Excel formatting:
   - Headers styled with blue background
   - Status cells colored (completed=green, cancelled=red, draft=light green)
   - All columns present and labeled correctly
   - Chinese characters display correctly

5. Test large dataset:
   - Export 1000+ tasks
   - Verify completes without timeout
   - Verify file size reasonable
</verification>

<success_criteria>
1. TaskExportMixin created with export_excel endpoint
2. BaseWorkOrderTaskViewSet includes TaskExportMixin
3. Frontend exportExcel method with blob response type
4. handleExport uses backend API instead of client-side generation
5. Export respects filters and selected tasks
6. Excel file has proper formatting and Chinese character support
7. Large datasets export efficiently
</success_criteria>

<output>
After completion, create `.planning/phases/05-Universal-Task-Visibility/05-04-SUMMARY.md` with:
- TaskExportMixin implementation details
- Excel styling and formatting features
- Frontend-backend integration
- Export testing results
</output>
