---
phase: 03-Dispatch-Configuration
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - backend/workorder/services/dispatch_service.py
  - backend/workorder/models/system.py
  - backend/workorder/models/core.py
autonomous: false

must_haves:
  truths:
    - "System automatically dispatches tasks to highest-priority department when work order is approved"
    - "Auto-dispatch respects configured priority rules from TaskAssignmentRule"
    - "Dispatch happens during draft-to-formal task conversion (approval workflow)"
    - "Tasks with status='draft' are not assigned to departments during generation"
    - "Only after approval do tasks get assigned via auto-dispatch"
  artifacts:
    - path: "backend/workorder/services/dispatch_service.py"
      provides: "AutoDispatchService with dispatch_task() method"
      min_lines: 60
    - path: "backend/workorder/models/core.py"
      provides: "Updated _auto_assign_task() using AutoDispatchService"
      exports: ["_auto_assign_task", "convert_draft_tasks"]
  key_links:
    - from: "backend/workorder/models/core.py"
      to: "backend/workorder/services/dispatch_service.py"
      via: "AutoDispatchService.dispatch_task()"
      pattern: "AutoDispatchService"
    - from: "backend/workorder/models/core.py"
      to: "convert_draft_tasks"
      via: "Approval workflow calling auto-dispatch"
      pattern: "assigned_department"
---

<objective>
Implement auto-dispatch service that assigns tasks to departments based on configured priority rules during work order approval.

Purpose: Integrate dispatch configuration with the existing approval workflow so that when a work order is approved, draft tasks are automatically assigned to the highest-priority department configured for each process.

Output: AutoDispatchService that selects target department based on priority rules, integrated with draft-to-formal conversion in approval workflow.
</objective>

<execution_context>
@/home/chenjiaxing/.claude/get-shit-done/workflows/execute-plan.md
@/home/chenjiaxing/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context (Plan 01 provides DispatchPreviewService)
@.planning/phases/03-Dispatch-Configuration/03-01-SUMMARY.md

# Approval workflow integration
@.planning/phases/01-draft-task-foundation/01-03-SUMMARY.md

# Existing code to modify
@/home/chenjiaxing/文档/work_order/backend/workorder/models/core.py
@/home/chenjiaxing/文档/work_order/backend/workorder/services/dispatch_service.py
@/home/chenjiaxing/文档/work_order/backend/workorder/models/system.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AutoDispatchService with priority-based department selection</name>
  <files>backend/workorder/services/dispatch_service.py</files>
  <action>
    Add AutoDispatchService class to `backend/workorder/services/dispatch_service.py`:

    1. **AutoDispatchService class** with static methods:

       **dispatch_task(task, process=None)**:
       - Main method to assign a task to a department based on priority rules
       - If process not provided, get from task.work_order_process
       - Query TaskAssignmentRule for the process:
         ```python
         rules = TaskAssignmentRule.objects.filter(
             process=process,
             is_active=True
         ).select_related('department').order_by('-priority')
         ```
       - Check each rule in priority order:
         * Verify department is in process's available departments
         * If match found, assign task.assigned_department = rule.department
       - Fallback: if no rules match, use existing _auto_assign_task logic (first available department)
       - Return the assigned department or None

       **get_highest_priority_department(process)**:
       - Get the highest priority active rule for a process
       - Return the department or None
       - Used by preview service

       **is_department_available_for_process(department, process)**:
       - Check if department is in process.departments (process's available departments)
       - Return True if department can handle the process

    2. **Import requirements**:
       ```python
       from ..models.system import TaskAssignmentRule
       from ..models.base import Department
       ```

    3. **Edge case handling**:
       - If no active rules exist, return None (caller handles fallback)
       - If rule's department not in process's available departments, skip to next rule
       - Log skipped rules for debugging

    Follow the service layer pattern established in task_generation.py.
  </action>
  <verify>
    grep -n "class AutoDispatchService" backend/workorder/services/dispatch_service.py
    python manage.py shell -c "from workorder.services.dispatch_service import AutoDispatchService; print(AutoDispatchService.dispatch_task.__doc__)"
  </verify>
  <done>
    AutoDispatchService exists in dispatch_service.py with dispatch_task() method that returns highest priority department for a process.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor _auto_assign_task to use AutoDispatchService</name>
  <files>backend/workorder/models/core.py</files>
  <action>
    Update the `_auto_assign_task()` method in `backend/workorder/models/core.py` (WorkOrderProcess class):

    1. **Import AutoDispatchService**:
       ```python
       from ..services.dispatch_service import AutoDispatchService
       ```

    2. **Update _auto_assign_task() to use the service**:
       - Keep existing structure: first check if self.department is set
       - Replace the manual rule query with AutoDispatchService call:
         ```python
         # OLD CODE (remove):
         assignment_rules = TaskAssignmentRule.objects.filter(...)
         # ... manual priority iteration

         # NEW CODE (replace with):
         assigned_dept = AutoDispatchService.dispatch_task(task, self.process)
         if assigned_dept:
             task.assigned_department = assigned_dept
         ```

    3. **Preserve existing fallback logic**:
       - If AutoDispatchService returns None, use existing fallback to first available department
       - Keep operator selection logic (using rule's strategy or default 'least_tasks')

    4. **Ensure backward compatibility**:
       - If process.department is set, still use it (highest priority override)
       - Don't change existing notification logic
       - Don't change operator selection behavior

    The refactoring should NOT change the external behavior, only use the new service internally.
  </action>
  <verify>
    grep -n "AutoDispatchService" backend/workorder/models/core.py
  </verify>
  <done>
    _auto_assign_task() uses AutoDispatchService.dispatch_task() for department assignment, preserves all existing behavior and fallbacks.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate auto-dispatch into convert_draft_tasks workflow</name>
  <files>backend/workorder/models/core.py</files>
  <action>
    Update the `convert_draft_tasks()` method in `backend/workorder/models/core.py` (WorkOrder class):

    1. **Locate convert_draft_tasks() method** (already exists from Phase 1)

    2. **Add auto-dispatch call after status conversion**:
       - Find the section where tasks are updated to 'pending' status
       - After the bulk_update for status, add department dispatch:
         ```python
         # Convert status to pending
         for task in draft_tasks:
             task.status = 'pending'

         # NEW: Auto-dispatch to departments
         for task in draft_tasks:
             work_order_process = task.work_order_process
             if work_order_process:
                 work_order_process._auto_assign_task(task)
         ```

    3. **Batch update with assigned_department**:
       - After calling _auto_assign_task for all tasks, do a bulk_update:
         ```python
         WorkOrderTask.objects.bulk_update(
             draft_tasks,
             ['status', 'assigned_department', 'assigned_operator'],
             batch_size=100
         )
         ```

    4. **Alternative: Save individually if bulk_update is complex**:
       - If _auto_assign_task has side effects (notifications), may need to call task.save() instead
       - Check existing implementation - _auto_assign_task already calls task.save() at the end
       - If so, just ensure it's called for each task during conversion

    5. **Verify notification triggers**:
       - _auto_assign_task creates task_assigned notifications
       - Ensure notifications are created during draft conversion

    The key is ensuring that when work order is approved, all draft tasks get assigned to departments based on priority rules.
  </action>
  <verify>
    grep -A 20 "def convert_draft_tasks" backend/workorder/models/core.py | grep -c "_auto_assign_task"
  </verify>
  <done>
    convert_draft_tasks() calls _auto_assign_task() for each draft task, assigning them to departments based on priority rules.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add global dispatch enabled flag check</name>
  <files>backend/workorder/services/dispatch_service.py</files>
  <action>
    Add global dispatch toggle support to AutoDispatchService:

    1. **Add is_global_dispatch_enabled() static method**:
       ```python
   @staticmethod
   def is_global_dispatch_enabled():
       """Check if global auto-dispatch is enabled

       Returns:
           bool: True if dispatch is enabled, False otherwise
       """
       from django.core.cache import cache

       # Check cache first (default: disabled)
       return cache.get('dispatch_global_enabled', False)
       ```

    2. **Add set_global_dispatch_enabled(enabled) static method**:
       ```python
   @staticmethod
   def set_global_dispatch_enabled(enabled):
       """Set global auto-dispatch enabled state

       Args:
           enabled (bool): True to enable, False to disable

       Returns:
           bool: New state
       """
       from django.core.cache import cache

       cache.set('dispatch_global_enabled', enabled, timeout=None)
       return enabled
       ```

    3. **Update dispatch_task() to check global flag**:
       - At start of dispatch_task(), check: `if not AutoDispatchService.is_global_dispatch_enabled(): return None`
       - If disabled, return None immediately (caller uses fallback)
       - Add docstring noting this behavior

    4. **Add API endpoint to toggle global state** (optional, or handle via settings):
       - For now, use cache-based toggle
       - Frontend will call via preview endpoint or separate toggle endpoint

    5. **Export new methods**:
       - Update __init__.py to export is_global_dispatch_enabled and set_global_dispatch_enabled

    The global toggle defaults to FALSE (disabled) per CONTEXT decision.
  </action>
  <verify>
    grep -n "is_global_dispatch_enabled\|set_global_dispatch_enabled" backend/workorder/services/dispatch_service.py
  python manage.py shell -c "from workorder.services.dispatch_service import AutoDispatchService; AutoDispatchService.set_global_dispatch_enabled(True); print(AutoDispatchService.is_global_dispatch_enabled())"
  </verify>
  <done>
    AutoDispatchService has global enabled check, dispatch_task() returns None when disabled, toggle methods work correctly.
  </done>
</task>

<task type="auto">
  <name>Task 5: Add global dispatch toggle API endpoint</name>
  <files>backend/workorder/views/system.py</files>
  <action>
    Add toggle action to TaskAssignmentRuleViewSet in `backend/workorder/views/system.py`:

    1. **Import AutoDispatchService** (if not already imported):
       ```python
       from ..services.dispatch_service import AutoDispatchService
       ```

    2. **Add get_global_state action**:
       ```python
   @action(detail=False, methods=['get'])
   def global_state(self, request):
       """Get global auto-dispatch enabled state"""
       enabled = AutoDispatchService.is_global_dispatch_enabled()
       return Response({'enabled': enabled})
       ```

    3. **Add set_global_state action**:
       ```python
   @action(detail=False, methods=['post'])
   def set_global_state(self, request):
       """Set global auto-dispatch enabled state

       Body:
           enabled (bool): True to enable, False to disable
       """
       enabled = request.data.get('enabled', False)
       new_state = AutoDispatchService.set_global_dispatch_enabled(enabled)
       return Response({'enabled': new_state})
       ```

    4. **Include global state in preview response**:
       - Update the preview() action from Plan 01
       - Add 'global_enabled' to response:
         ```python
         return Response({
             'preview': preview_data,
             'global_enabled': AutoDispatchService.is_global_dispatch_enabled(),
             'generated_at': timezone.now().isoformat()
         })
       ```

    This allows frontend to fetch and toggle global dispatch state via API.
  </action>
  <verify>
    curl -X GET http://localhost:8000/api/task-assignment-rules/global_state/
    curl -X POST http://localhost:8000/api/task-assignment-rules/set_global_state/ -d '{"enabled": true}'
  </verify>
  <done>
    GET /api/task-assignment-rules/global_state/ returns current enabled state, POST /api/task-assignment-rules/set_global_state/ updates it.
  </done>
</task>

<task type="auto">
  <name>Task 6: Update frontend API with global state methods</name>
  <files>frontend/src/api/modules/task-assignment-rule.js</files>
  <action>
    Extend TaskAssignmentRuleAPI class in `frontend/src/api/modules/task-assignment-rule.js`:

    1. **Add getGlobalState() method**:
       ```javascript
   getGlobalState() {
     return this.request({
       url: `${this.baseURL}global_state/`,
       method: 'get'
     })
   }
       ```

    2. **Add setGlobalState(enabled) method**:
       ```javascript
   setGlobalState(enabled) {
     return this.request({
       url: `${this.baseURL}set_global_state/`,
       method: 'post',
       data: { enabled }
     })
   }
       ```

    3. **Update preview() to handle global_enabled**:
       - Modify preview() to return full response including global_enabled
       - Existing implementation should already return full response data

    Follow the BaseAPI pattern for consistent method signatures.
  </action>
  <verify>
    grep -n "getGlobalState\|setGlobalState" frontend/src/api/modules/task-assignment-rule.js
  </verify>
  <done>
    taskAssignmentRuleAPI has getGlobalState() and setGlobalState() methods that call the respective endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 7: Wire up global toggle in AssignmentRule component</name>
  <files>frontend/src/views/task/AssignmentRule.vue</files>
  <action>
    Update AssignmentRule.vue to integrate global dispatch toggle with backend API:

    1. **Update globalDispatchEnabled data property**:
       - Change from localStorage-only to API-backed
       - Still use localStorage as fallback/initial value

    2. **Add loadGlobalState() method**:
       ```javascript
   async loadGlobalState() {
     try {
       const response = await this.apiService.getGlobalState()
       this.globalDispatchEnabled = response.enabled
     } catch (error) {
       // Fallback to localStorage on error
       const stored = localStorage.getItem('dispatch_global_enabled')
       this.globalDispatchEnabled = stored === 'true'
     }
   }
       ```

    3. **Update handleGlobalToggle() method**:
       ```javascript
   async handleGlobalToggle(value) {
     try {
       await this.apiService.setGlobalState(value)
       this.globalDispatchEnabled = value
       localStorage.setItem('dispatch_global_enabled', value)
       ErrorHandler.showSuccess(
         value ? '自动分派已启用' : '自动分派已禁用'
       )
       await this.generatePreview()
     } catch (error) {
       ErrorHandler.showMessage(error, '更新分派状态')
     }
   }
       ```

    4. **Call loadGlobalState() in mounted()**:
       - Before generating preview, call loadGlobalState()
       - Sequence: loadProcessList() -> loadGlobalState() -> loadData() -> generatePreview()

    5. **Update preview display**:
       - In generatePreview(), extract global_enabled from response
       - Pass to DispatchPreviewTable component

    6. **Add visual indicator**:
       - Show warning banner when global_dispatch_enabled is false
       - Use el-alert component: "自动分派已禁用 - 仅预览，任务不会实际分派"

    Ensure the toggle state is synced with backend on page load.
  </action>
  <verify>
    grep -n "loadGlobalState\|getGlobalState\|setGlobalState" frontend/src/views/task/AssignmentRule.vue
  </verify>
  <done>
    AssignmentRule.vue loads global dispatch state from API on mount, toggle changes sync to backend, preview shows current state.
  </done>
</task>

<task type="checkpoint:human-verify">
  <what-built>Auto-dispatch service integration (Tasks 1-7)</what-built>
  <how-to-verify>
    1. **Backend verification**:
       - Create a test work order with some processes
       - Configure TaskAssignmentRule records with different priorities for the processes
       - Approve the work order
       - Verify tasks are assigned to highest-priority departments
       - Check task.assigned_department is set correctly

    2. **Global toggle verification**:
       - Call GET /api/task-assignment-rules/global_state/ (should return enabled: False by default)
       - Call POST /api/task-assignment-rules/set_global_state/ with {"enabled": true}
       - Approve a work order and verify tasks are now assigned
       - Disable toggle and approve another work order - tasks should NOT be assigned

    3. **Frontend verification**:
       - Navigate to AssignmentRule page
       - Toggle global dispatch switch
       - Verify API is called (check Network tab)
       - Refresh page - verify toggle state persists

    4. **End-to-end workflow**:
       - Create work order (draft tasks generated, no department assigned)
       - Configure dispatch rules for processes
       - Enable global dispatch
       - Approve work order
       - Verify tasks converted to pending status AND assigned to departments
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **AutoDispatchService functionality**:
   - dispatch_task() returns highest priority department for a process
   - Returns None when global dispatch is disabled
   - Respects is_active flag on rules

2. **Approval workflow integration**:
   - convert_draft_tasks() calls _auto_assign_task() for each task
   - Tasks receive assigned_department after approval
   - Notifications are created for assigned tasks

3. **Global toggle behavior**:
   - API endpoints return and update global state
   - Frontend toggle syncs with backend
   - Disabled toggle prevents auto-dispatch during approval

4. **Backward compatibility**:
   - Existing _auto_assign_task() behavior preserved
   - Fallback to first available department still works
   - Process-level department override still takes priority
</verification>

<success_criteria>
Phase 3 Plan 2 is successful when:

1. System automatically dispatches tasks to highest-priority department when work order is approved (with global toggle enabled)
2. Auto-dispatch respects configured priority rules from TaskAssignmentRule
3. Dispatch happens during draft-to-formal task conversion in approval workflow
4. Tasks with status='draft' remain unassigned during generation
5. Only after approval do tasks get assigned via auto-dispatch
6. Global toggle controls whether dispatch occurs during approval
</success_criteria>

<output>
After completion, create `.planning/phases/03-Dispatch-Configuration/03-02-SUMMARY.md`
</output>
