---
phase: 03-Dispatch-Configuration
plan: 03
type: execute
wave: 3
depends_on: [03-02]
files_modified:
  - backend/workorder/services/dispatch_service.py
  - backend/workorder/models/core.py
  - frontend/src/api/modules/task-assignment-rule.js
  - frontend/src/views/task/AssignmentRule.vue
  - frontend/src/components/dispatch/DepartmentPriorityPanel.vue
autonomous: false

must_haves:
  truths:
    - "Load balancing strategy selects department with least pending tasks among equal-priority departments"
    - "Preview displays current task load for each department"
    - "Department selection considers only pending tasks (not in-progress)"
    - "Multiple departments at same priority level trigger load balancing selection"
    - "Strategy selection per rule (least_tasks, random, round_robin, first_available)"
  artifacts:
    - path: "backend/workorder/services/dispatch_service.py"
      provides: "LoadBalancingService with select_department_by_load()"
      min_lines: 80
    - path: "backend/workorder/models/core.py"
      provides: "Updated _select_operator_by_strategy() using load balancing"
      exports: ["_select_operator_by_strategy"]
  key_links:
    - from: "backend/workorder/services/dispatch_service.py"
      to: "backend/workorder/models/core.py"
      via: "LoadBalancingService.select_department_by_load()"
      pattern: "LoadBalancingService"
    - from: "frontend/src/components/dispatch/DepartmentPriorityPanel.vue"
      to: "load calculation"
      via: "Display current load in department cards"
      pattern: "current_load"
---

<objective>
Implement workload balancing strategy that selects the least-loaded department when multiple departments have equal priority.

Purpose: When multiple departments are configured at the same priority level for a process, the system should distribute tasks evenly based on current workload, preventing overloading of a single department.

Output: LoadBalancingService that selects departments based on pending task counts, integrated with AutoDispatchService and displayed in preview UI.
</objective>

<execution_context>
@/home/chenjiaxing/.claude/get-shit-done/workflows/execute-plan.md
@/home/chenjiaxing/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context
@.planning/phases/03-Dispatch-Configuration/03-01-SUMMARY.md
@.planning/phases/03-Dispatch-Configuration/03-02-SUMMARY.md

# Existing code to extend
@/home/chenjiaxing/文档/work_order/backend/workorder/services/dispatch_service.py
@/home/chenjiaxing/文档/work_order/backend/workorder/models/core.py
@/home/chenjiaxing/文档/work_order/frontend/src/components/dispatch/DepartmentPriorityPanel.vue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LoadBalancingService with department load calculation</name>
  <files>backend/workorder/services/dispatch_service.py</files>
  <action>
    Add LoadBalancingService class to `backend/workorder/services/dispatch_service.py`:

    1. **LoadBalancingService class** with static methods:

       **calculate_department_load(department)**:
       - Count tasks assigned to department with status in ['pending', 'in_progress']
       - Use efficient query with .filter(assigned_department=department, status__in=['pending', 'in_progress']).count()
       - Return integer count
       - Consider caching if performance issues (use django.utils.cache)

       **select_department_by_load(process)**:
       - Get all active TaskAssignmentRule for the process, ordered by priority
       - Group rules by priority level
       - For highest priority group:
         * If only one department, return it
         * If multiple departments at same priority, select by load:
           - Calculate load for each department using calculate_department_load()
           - Sort by load (ascending)
           - Return department with lowest load
       - If no rules found, return None

       **select_department_by_strategy(process, strategy='least_tasks')**:
       - Wrapper supporting multiple strategies
       - 'least_tasks': Use select_department_by_load()
       - 'random': Random selection from equal priority departments
       - 'round_robin': Round-robin selection (need to track last selected)
       - 'first_available': First department in priority order
       - For Phase 3, implement 'least_tasks' fully, stub others for future

    2. **Import requirements**:
       ```python
       from ..models import WorkOrderTask
       from collections import defaultdict
       import random
       ```

    3. **Round-robin implementation** (optional, for future):
       - Use cache to track last selected index per process
       - Cache key: f'dispatch_rr_{process_id}'
       - Increment and wrap around

    4. **Add get_loads_for_process(process) helper**:
       - Returns dict mapping department_id -> load count
       - Used by preview API to display all loads

    Follow the service layer pattern established in task_generation.py.
  </action>
  <verify>
    grep -n "class LoadBalancingService" backend/workorder/services/dispatch_service.py
    python manage.py shell -c "from workorder.services.dispatch_service import LoadBalancingService; print(LoadancingService.select_department_by_load.__doc__)"
  </verify>
  <done>
    LoadBalancingService exists with calculate_department_load() and select_department_by_load() methods that select based on pending task counts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate load balancing into AutoDispatchService</name>
  <files>backend/workorder/services/dispatch_service.py</files>
  <action>
    Update AutoDispatchService.dispatch_task() in `backend/workorder/services/dispatch_service.py`:

    1. **Modify dispatch_task() to use load balancing**:
       - After fetching rules ordered by priority, group by priority level
       - Identify highest priority group
       - If multiple rules in highest priority group:
         ```python
         # Group rules by priority
         priority_groups = defaultdict(list)
         for rule in rules:
             priority_groups[rule.priority].append(rule)

         # Get highest priority
         highest_priority = max(priority_groups.keys()) if priority_groups else None
         if highest_priority:
             highest_group = priority_groups[highest_priority]

             # If multiple departments at same priority, use load balancing
             if len(highest_group) > 1:
                 department = LoadBalancingService.select_department_by_load(process)
                 return department
             else:
                 return highest_group[0].department
         ```

    2. **Preserve single-department shortcut**:
       - If only one rule or only one at highest priority, use it directly
       - Load balancing only activates for equal-priority tiebreaker

    3. **Add strategy parameter support**:
       - dispatch_task() accepts optional strategy parameter
       - Defaults to 'least_tasks'
       - Passes to LoadBalancingService for selection

    4. **Add logging for debugging**:
       - Log when load balancing triggers
       - Log selected department and its load
       - Use Python logging module: `import logging; logger = logging.getLogger(__name__)`

    Ensure the modification doesn't break existing single-department dispatch.
  </action>
  <verify>
    grep -n "LoadBalancingService" backend/workorder/services/dispatch_service.py | head -5
  </verify>
  <done>
    AutoDispatchService.dispatch_task() uses LoadBalancingService when multiple departments have equal priority.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add load information to dispatch preview</name>
  <files>backend/workorder/services/dispatch_service.py</files>
  <action>
    Update DispatchPreviewService.generate_preview() in `backend/workorder/services/dispatch_service.py`:

    1. **Modify generate_preview() to include load for all departments**:
       - For each process, get all active rules (not just highest priority)
       - Calculate load for each department in the rules
       - Return expanded preview data:
         ```python
         {
             'process_id': process.id,
             'process_name': process.name,
             'process_code': process.code,
             'target_department_id': rule.department.id,
             'target_department_name': rule.department.name,
             'current_load': dept_load,
             'priority': rule.priority,
             'is_active': rule.is_active,
             'all_departments': [
                 {
                     'department_id': r.department.id,
                     'department_name': r.department.name,
                     'priority': r.priority,
                     'load': calculate_load(r.department),
                     'is_active': r.is_active
                 }
                 for r in rules
             ]
         }
         ```

    2. **Add calculate_load_for_department() helper**:
       - Centralized load calculation for reuse
       - Returns pending + in_progress task count for department
       - Used by both preview and load balancing

    3. **Optimize query performance**:
       - Use aggregation to count tasks per department in single query:
         ```python
         from django.db.models import Count

         dept_loads = WorkOrderTask.objects.filter(
             assigned_department__in=[r.department for r in rules],
             status__in=['pending', 'in_progress']
         ).values('assigned_department').annotate(
             load=Count('id')
         )

         load_dict = {item['assigned_department']: item['load'] for item in dept_loads}
         ```

    The preview now shows load for all configured departments, not just the selected one.
  </action>
  <verify>
    grep -n "all_departments" backend/workorder/services/dispatch_service.py
  </verify>
  <done>
    Preview response includes all_departments array with load for each configured department.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update DepartmentPriorityPanel to display load info</name>
  <files>frontend/src/components/dispatch/DepartmentPriorityPanel.vue</files>
  <action>
    Update DepartmentPriorityPanel.vue to display load information:

    1. **Update props to receive load data**:
       - Add `departmentLoads` prop (Object mapping dept_id -> load count)
       - Or add `allDepartments` prop with full load info

    2. **Update department card template**:
       - Display current load prominently in each department card
       - Use color-coded badge based on load:
         * Green: 0-5 tasks
         * Yellow: 6-15 tasks
         * Red: 16+ tasks
       - Show "当前负载: X 个任务" text

    3. **Add load comparison indicator**:
       - For multiple departments at same priority, highlight lowest load
       - Add "推荐选择" (recommended) badge for least-loaded department
       - Only show when comparing equal-priority departments

    4. **Style updates**:
       - Add CSS classes for load indicators
       - Use flexbox to align priority badge, department info, and load

    5. **Add load refresh**:
       - Pass preview refresh method to child components
       - Auto-refresh loads after priority changes

    Make load information visible at a glance in the priority panel.
  </action>
  <verify>
    grep -n "current_load\|负载" frontend/src/components/dispatch/DepartmentPriorityPanel.vue
  </verify>
  <done>
    DepartmentPriorityPanel displays current task load for each department with color-coded badges.
  </done>
</task>

<task type="auto">
  <name>Task 5: Update DispatchPreviewTable to show all departments with loads</name>
  <files>frontend/src/components/dispatch/DispatchPreviewTable.vue</files>
  <action>
    Update DispatchPreviewTable.vue to display all configured departments:

    1. **Modify template to expand target department row**:
       - Use el-table with expand rows feature
       - Main row shows: process info, target department, target department load
       - Expanded row shows: all departments configured for this process with their loads

    2. **Alternative: Nested table structure**:
       - Keep existing table structure
       - Add "所有配置部门" column showing count and expand icon
       - When expanded, show sub-table with:
         * Department name
         * Priority
         * Load count
         * Load progress bar
         * Active/inactive status

    3. **Update component props/data**:
       - Accept previewData with all_departments array
       - Handle both old format (backward compat) and new format

    4. **Add styling for expandable rows**:
       - Indented sub-table
       - Lighter background for expanded content
       - Border separator

    5. **Add load comparison highlight**:
       - In expanded view, highlight the selected department
       - Show why it was selected (highest priority, or lowest load in tiebreaker)

    The preview table now gives full visibility into dispatch configuration and selection reasoning.
  </action>
  <verify>
    grep -n "all_departments\|expand" frontend/src/components/dispatch/DispatchPreviewTable.vue
  </verify>
  <done>
    DispatchPreviewTable shows expandable rows with all configured departments and their loads.
  </done>
</task>

<task type="auto">
  <name>Task 6: Add operator selection strategy display and update</name>
  <files>frontend/src/components/dispatch/DepartmentPriorityPanel.vue</files>
  <action>
    Add operator selection strategy controls to DepartmentPriorityPanel:

    1. **Add strategy selector to department card**:
       - Each department card shows current strategy (least_tasks, random, etc.)
       - Add dropdown to change strategy per department
       - Use el-select with strategy options

    2. **Update form data structure**:
       - Each department rule has operator_selection_strategy field
       - Display readable label: "任务量均衡", "随机选择", "轮询分配", "首个可用"

    3. **Add strategy change handler**:
       - `handleStrategyChange(rule, newStrategy)`: Emits event to parent
       - Calls API to update rule's operator_selection_strategy
       - Refreshes preview after update

    4. **Add strategy icons/indicators**:
       - Show icon representing current strategy
       * least_tasks: 均衡 icon
       * random: 随机 icon
       * round_robin: 循环 icon
       * first_available: 第一个 icon

    5. **Update parent component**:
       - AssignmentRule.vue handles strategy change events
       - Calls API to update rule
       - Regenerates preview

    Strategy selection controls how operators are chosen within a department (Phase 4 will use this).
  </action>
  <verify>
    grep -n "operator_selection_strategy\|strategy" frontend/src/components/dispatch/DepartmentPriorityPanel.vue
  </verify>
  <done>
    DepartmentPriorityPanel displays and allows editing operator selection strategy per department rule.
  </done>
</task>

<task type="checkpoint:human-verify">
  <what-built>Load balancing service and UI enhancements (Tasks 1-6)</what-built>
  <how-to-verify>
    1. **Backend load balancing verification**:
       - Configure multiple departments with SAME priority for a process
       - Create some tasks assigned to each department (different counts)
       - Call AutoDispatchService.dispatch_task() for the process
       - Verify it selects the department with LOWEST task count
       - Repeat with equal task counts - verify consistent selection

    2. **Preview load information verification**:
       - Call GET /api/task-assignment-rules/preview/
       - Verify response includes all_departments array
       - Check each department has accurate load count
       - Verify target_department is the one with highest priority or lowest load

    3. **Frontend UI verification**:
       - Navigate to AssignmentRule page
       - Select a process with multiple departments
       - Verify each department card shows current load
       - Verify load badges are color-coded (green/yellow/red)
       - Verify "推荐选择" badge appears on least-loaded department
       - Expand preview table row - verify all departments shown with loads

    4. **Strategy selection verification**:
       - Click strategy dropdown on a department card
       - Change from "任务量均衡" to "随机选择"
       - Verify API call succeeds
       - Verify preview refreshes

    5. **End-to-end workflow**:
       - Configure 3 departments for "印刷" process, all priority 50
       - Create tasks: Dept A has 10, Dept B has 3, Dept C has 7
       - Approve work order with 印刷 process
       - Verify new task assigned to Dept B (lowest load = 3)
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **LoadBalancingService functionality**:
   - calculate_department_load() returns accurate pending+in_progress task counts
   - select_department_by_load() returns department with lowest load among equal-priority options
   - Load calculations use efficient aggregation queries

2. **AutoDispatchService integration**:
   - dispatch_task() uses load balancing for equal-priority tiebreaker
   - Single-department selection unaffected
   - Strategy parameter passed through correctly

3. **Preview enhancements**:
   - all_departments array includes all configured departments with loads
   - Frontend displays load information prominently
   - Expandable rows show full configuration context

4. **UI improvements**:
   - Department cards show current load with color coding
   - Preview table expands to show all departments
   - Strategy selection dropdown functional
</verification>

<success_criteria>
Phase 3 Plan 3 is successful when:

1. Load balancing selects department with least pending tasks among equal-priority departments
2. Preview displays current task load for each department
3. Department selection considers only pending tasks (not in-progress)
4. Multiple departments at same priority level trigger load balancing selection
5. Strategy selection per rule (least_tasks, random, round_robin, first_available) is displayed and editable
</success_criteria>

<output>
After completion, create `.planning/phases/03-Dispatch-Configuration/03-03-SUMMARY.md`
</output>
